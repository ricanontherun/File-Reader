!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/7d6be56/
ACCESS_ADVICE	file.h	/^  enum class ACCESS_ADVICE {$/;"	g	class:File
AND_THEN	tests/catch.hpp	/^#define AND_THEN(/;"	d
AND_WHEN	tests/catch.hpp	/^#define AND_WHEN(/;"	d
ANON_TEST_CASE	tests/catch.hpp	/^#define ANON_TEST_CASE(/;"	d
AllOf	tests/catch.hpp	/^  AllOf() {}$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf
AllOf	tests/catch.hpp	/^  AllOf(AllOf const &other) : m_matchers(other.m_matchers) {}$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf
AllOf	tests/catch.hpp	/^class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic
AllOf	tests/catch.hpp	/^inline Impl::Generic::AllOf<ExpressionT> AllOf(Impl::Matcher<ExpressionT> const &m1,$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::Generic::AllOf<ExpressionT>
Always	tests/catch.hpp	/^        Always,$/;"	e	enum:Catch::ShowDurations::OrNot
AnyOf	tests/catch.hpp	/^  AnyOf() {}$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf
AnyOf	tests/catch.hpp	/^  AnyOf(AnyOf const &other) : m_matchers(other.m_matchers) {}$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf
AnyOf	tests/catch.hpp	/^class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic
AnyOf	tests/catch.hpp	/^inline Impl::Generic::AnyOf<ExpressionT> AnyOf(Impl::Matcher<ExpressionT> const &m1,$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::Generic::AnyOf<ExpressionT>
Approx	tests/catch.hpp	/^  Approx(Approx const &other)$/;"	f	class:Catch::Detail::Approx
Approx	tests/catch.hpp	/^  explicit Approx(double value)$/;"	f	class:Catch::Detail::Approx
Approx	tests/catch.hpp	/^class Approx {$/;"	c	namespace:Catch::Detail
Arch	tests/catch.hpp	/^            enum Arch { Big, Little };$/;"	g	struct:Catch::Detail::__anond33fe2000810::Endianness
Arg	tests/catch.hpp	/^            Arg( Detail::BoundArgFunction<ConfigT> const& _boundField ) : CommonArgProperties<Co/;"	f	struct:Clara::CommandLine::Arg
Arg	tests/catch.hpp	/^            Arg() {}$/;"	f	struct:Clara::CommandLine::Arg
Arg	tests/catch.hpp	/^        struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties /;"	s	class:Clara::CommandLine
ArgAutoPtr	tests/catch.hpp	/^        typedef CLARA_AUTO_PTR( Arg ) ArgAutoPtr;$/;"	t	class:Clara::CommandLine
ArgBuilder	tests/catch.hpp	/^            ArgBuilder( Arg* arg ) : m_arg( arg ) {}$/;"	f	class:Clara::CommandLine::ArgBuilder
ArgBuilder	tests/catch.hpp	/^        class ArgBuilder {$/;"	c	class:Clara::CommandLine
AssertionInfo	tests/catch.hpp	/^    AssertionInfo::AssertionInfo(   std::string const& _macroName,$/;"	f	class:Catch::AssertionInfo
AssertionInfo	tests/catch.hpp	/^  AssertionInfo() {}$/;"	f	struct:Catch::AssertionInfo
AssertionInfo	tests/catch.hpp	/^struct AssertionInfo {$/;"	s	namespace:Catch
AssertionPrinter	tests/catch.hpp	/^            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printIn/;"	f	class:Catch::CompactReporter::AssertionPrinter
AssertionPrinter	tests/catch.hpp	/^            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printIn/;"	f	class:Catch::ConsoleReporter::AssertionPrinter
AssertionPrinter	tests/catch.hpp	/^        class AssertionPrinter {$/;"	c	struct:Catch::CompactReporter
AssertionPrinter	tests/catch.hpp	/^        class AssertionPrinter {$/;"	c	struct:Catch::ConsoleReporter
AssertionResult	tests/catch.hpp	/^    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data/;"	f	class:Catch::AssertionResult
AssertionResult	tests/catch.hpp	/^    AssertionResult::AssertionResult() {}$/;"	f	class:Catch::AssertionResult
AssertionResult	tests/catch.hpp	/^class AssertionResult {$/;"	c	namespace:Catch
AssertionResultData	tests/catch.hpp	/^  AssertionResultData() : resultType(ResultWas::Unknown) {}$/;"	f	struct:Catch::AssertionResultData
AssertionResultData	tests/catch.hpp	/^struct AssertionResultData {$/;"	s	namespace:Catch
AssertionStats	tests/catch.hpp	/^        AssertionStats( AssertionResult const& _assertionResult,$/;"	f	struct:Catch::AssertionStats
AssertionStats	tests/catch.hpp	/^    struct AssertionStats {$/;"	s	namespace:Catch
Assertions	tests/catch.hpp	/^            typedef std::vector<AssertionStats> Assertions;$/;"	t	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:std::vector<AssertionStats>
Auto	tests/catch.hpp	/^        Auto,$/;"	e	enum:Catch::UseColour::YesOrNo
AutoReg	tests/catch.hpp	/^    AutoReg::AutoReg$/;"	f	class:Catch::AutoReg
AutoReg	tests/catch.hpp	/^  AutoReg$/;"	f	struct:Catch::AutoReg
AutoReg	tests/catch.hpp	/^struct AutoReg {$/;"	s	namespace:Catch
BetweenGenerator	tests/catch.hpp	/^  BetweenGenerator(T from, T to) : m_from(from), m_to(to) {}$/;"	f	class:Catch::BetweenGenerator
BetweenGenerator	tests/catch.hpp	/^class BetweenGenerator : public IGenerator<T> {$/;"	c	namespace:Catch
Big	tests/catch.hpp	/^            enum Arch { Big, Little };$/;"	e	enum:Catch::Detail::__anond33fe2000810::Endianness::Arch
Blue	tests/catch.hpp	/^            Blue,$/;"	e	enum:Catch::Colour::Code
BorgType	tests/catch.hpp	/^struct BorgType {$/;"	s	namespace:Catch::Detail
BoundArgFunction	tests/catch.hpp	/^            BoundArgFunction( BoundArgFunction const& other ) : functionObj( other.functionObj ?/;"	f	class:Clara::Detail::BoundArgFunction
BoundArgFunction	tests/catch.hpp	/^            BoundArgFunction( IArgFunction<ConfigT>* _functionObj ) : functionObj( _functionObj /;"	f	class:Clara::Detail::BoundArgFunction
BoundArgFunction	tests/catch.hpp	/^            BoundArgFunction() : functionObj( CLARA_NULL ) {}$/;"	f	class:Clara::Detail::BoundArgFunction
BoundArgFunction	tests/catch.hpp	/^        class BoundArgFunction {$/;"	c	namespace:Clara::Detail
BoundBinaryFunction	tests/catch.hpp	/^            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}$/;"	f	struct:Clara::Detail::BoundBinaryFunction
BoundBinaryFunction	tests/catch.hpp	/^        struct BoundBinaryFunction : IArgFunction<C>{$/;"	s	namespace:Clara::Detail
BoundDataMember	tests/catch.hpp	/^            BoundDataMember( M C::* _member ) : member( _member ) {}$/;"	f	struct:Clara::Detail::BoundDataMember
BoundDataMember	tests/catch.hpp	/^        struct BoundDataMember : IArgFunction<C>{$/;"	s	namespace:Clara::Detail
BoundNullaryMethod	tests/catch.hpp	/^            BoundNullaryMethod( void (C::*_member)() ) : member( _member ) {}$/;"	f	struct:Clara::Detail::BoundNullaryMethod
BoundNullaryMethod	tests/catch.hpp	/^        struct BoundNullaryMethod : IArgFunction<C>{$/;"	s	namespace:Clara::Detail
BoundUnaryFunction	tests/catch.hpp	/^            BoundUnaryFunction( void (*_function)( C& ) ) : function( _function ) {}$/;"	f	struct:Clara::Detail::BoundUnaryFunction
BoundUnaryFunction	tests/catch.hpp	/^        struct BoundUnaryFunction : IArgFunction<C>{$/;"	s	namespace:Clara::Detail
BoundUnaryMethod	tests/catch.hpp	/^            BoundUnaryMethod( void (C::*_member)( M ) ) : member( _member ) {}$/;"	f	struct:Clara::Detail::BoundUnaryMethod
BoundUnaryMethod	tests/catch.hpp	/^        struct BoundUnaryMethod : IArgFunction<C>{$/;"	s	namespace:Clara::Detail
Bright	tests/catch.hpp	/^            Bright = 0x10,$/;"	e	enum:Catch::Colour::Code
BrightGreen	tests/catch.hpp	/^            BrightGreen = Bright | Green,$/;"	e	enum:Catch::Colour::Code
BrightRed	tests/catch.hpp	/^            BrightRed = Bright | Red,$/;"	e	enum:Catch::Colour::Code
BrightWhite	tests/catch.hpp	/^            BrightWhite = Bright | White,$/;"	e	enum:Catch::Colour::Code
BySectionInfo	tests/catch.hpp	/^			BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}$/;"	f	struct:Catch::CumulativeReporterBase::BySectionInfo
BySectionInfo	tests/catch.hpp	/^            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}$/;"	f	struct:Catch::CumulativeReporterBase::BySectionInfo
BySectionInfo	tests/catch.hpp	/^        struct BySectionInfo {$/;"	s	struct:Catch::CumulativeReporterBase
C	tests/catch.hpp	/^            void (C::*member)( M );$/;"	m	struct:Clara::Detail::BoundUnaryMethod	typeref:typename:void (::* member)(M)
C	tests/catch.hpp	/^            void (C::*member)();$/;"	m	struct:Clara::Detail::BoundNullaryMethod	typeref:typename:void (::* member)()
C	tests/catch.hpp	/^  void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase	typeref:typename:void (::* m_method)()
CAPTURE	tests/catch.hpp	/^#define CAPTURE(/;"	d
CATCH_AND_THEN	tests/catch.hpp	/^#define CATCH_AND_THEN(/;"	d
CATCH_AND_WHEN	tests/catch.hpp	/^#define CATCH_AND_WHEN(/;"	d
CATCH_ANON_TEST_CASE	tests/catch.hpp	/^#define CATCH_ANON_TEST_CASE(/;"	d
CATCH_ARC_ENABLED	tests/catch.hpp	/^#define CATCH_ARC_ENABLED /;"	d
CATCH_ARC_STRONG	tests/catch.hpp	/^#define CATCH_ARC_STRONG /;"	d
CATCH_ARC_STRONG	tests/catch.hpp	/^#define CATCH_ARC_STRONG$/;"	d
CATCH_AUTO_PTR	tests/catch.hpp	/^#   define CATCH_AUTO_PTR(/;"	d
CATCH_BREAK_INTO_DEBUGGER	tests/catch.hpp	/^            #define CATCH_BREAK_INTO_DEBUGGER(/;"	d
CATCH_BREAK_INTO_DEBUGGER	tests/catch.hpp	/^    #define CATCH_BREAK_INTO_DEBUGGER(/;"	d
CATCH_BREAK_INTO_DEBUGGER	tests/catch.hpp	/^#define CATCH_BREAK_INTO_DEBUGGER(/;"	d
CATCH_CAPTURE	tests/catch.hpp	/^#define CATCH_CAPTURE(/;"	d
CATCH_CHECK	tests/catch.hpp	/^#define CATCH_CHECK(/;"	d
CATCH_CHECKED_ELSE	tests/catch.hpp	/^#define CATCH_CHECKED_ELSE(/;"	d
CATCH_CHECKED_IF	tests/catch.hpp	/^#define CATCH_CHECKED_IF(/;"	d
CATCH_CHECK_FALSE	tests/catch.hpp	/^#define CATCH_CHECK_FALSE(/;"	d
CATCH_CHECK_NOFAIL	tests/catch.hpp	/^#define CATCH_CHECK_NOFAIL(/;"	d
CATCH_CHECK_NOTHROW	tests/catch.hpp	/^#define CATCH_CHECK_NOTHROW(/;"	d
CATCH_CHECK_THROWS	tests/catch.hpp	/^#define CATCH_CHECK_THROWS(/;"	d
CATCH_CHECK_THROWS_AS	tests/catch.hpp	/^#define CATCH_CHECK_THROWS_AS(/;"	d
CATCH_CHECK_THROWS_WITH	tests/catch.hpp	/^#define CATCH_CHECK_THROWS_WITH(/;"	d
CATCH_CONFIG_COLOUR_ANSI	tests/catch.hpp	/^#       define CATCH_CONFIG_COLOUR_ANSI$/;"	d
CATCH_CONFIG_COLOUR_WINDOWS	tests/catch.hpp	/^#       define CATCH_CONFIG_COLOUR_WINDOWS$/;"	d
CATCH_CONFIG_CONSOLE_WIDTH	tests/catch.hpp	/^#define CATCH_CONFIG_CONSOLE_WIDTH /;"	d
CATCH_CONFIG_COUNTER	tests/catch.hpp	/^#   define CATCH_CONFIG_COUNTER$/;"	d
CATCH_CONFIG_CPP11_GENERATED_METHODS	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CATCH_CONFIG_CPP11_IS_ENUM	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_IS_ENUM$/;"	d
CATCH_CONFIG_CPP11_LONG_LONG	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_LONG_LONG$/;"	d
CATCH_CONFIG_CPP11_NOEXCEPT	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_NOEXCEPT$/;"	d
CATCH_CONFIG_CPP11_NULLPTR	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_CONFIG_CPP11_OVERRIDE	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_OVERRIDE$/;"	d
CATCH_CONFIG_CPP11_TUPLE	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_TUPLE$/;"	d
CATCH_CONFIG_CPP11_UNIQUE_PTR	tests/catch.hpp	/^#   define CATCH_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CATCH_CONFIG_MAIN	tests/FileOpenTests.cpp	/^#define CATCH_CONFIG_MAIN$/;"	d	file:
CATCH_CONFIG_MAIN	tests/TestInterface.cpp	/^#define CATCH_CONFIG_MAIN$/;"	d	file:
CATCH_CONFIG_VARIADIC_MACROS	tests/catch.hpp	/^#   define CATCH_CONFIG_VARIADIC_MACROS$/;"	d
CATCH_CPP11_OR_GREATER	tests/catch.hpp	/^#  define CATCH_CPP11_OR_GREATER$/;"	d
CATCH_FAIL	tests/catch.hpp	/^    #define CATCH_FAIL(/;"	d
CATCH_GENERATE	tests/catch.hpp	/^#define CATCH_GENERATE(/;"	d
CATCH_GIVEN	tests/catch.hpp	/^#define CATCH_GIVEN(/;"	d
CATCH_IMPL	tests/catch.hpp	/^#  define CATCH_IMPL$/;"	d
CATCH_INFO	tests/catch.hpp	/^#define CATCH_INFO(/;"	d
CATCH_INTERNAL_CONFIG_COUNTER	tests/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_COUNTER$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	tests/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	tests/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	tests/catch.hpp	/^#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	tests/catch.hpp	/^#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_TUPLE	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	tests/catch.hpp	/^#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	tests/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS$/;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	tests/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS$/;"	d
CATCH_INTERNAL_ERROR	tests/catch.hpp	/^#define CATCH_INTERNAL_ERROR(/;"	d
CATCH_INTERNAL_LINEINFO	tests/catch.hpp	/^#define CATCH_INTERNAL_LINEINFO /;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	tests/catch.hpp	/^#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS /;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	tests/catch.hpp	/^#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS$/;"	d
CATCH_METHOD_AS_TEST_CASE	tests/catch.hpp	/^    #define CATCH_METHOD_AS_TEST_CASE(/;"	d
CATCH_NOEXCEPT	tests/catch.hpp	/^                                                                                                /;"	d
CATCH_NOEXCEPT	tests/catch.hpp	/^#  define CATCH_NOEXCEPT /;"	d
CATCH_NOEXCEPT_IS	tests/catch.hpp	/^#  define CATCH_NOEXCEPT_IS(/;"	d
CATCH_NOT_IMPLEMENTED	tests/catch.hpp	/^#define CATCH_NOT_IMPLEMENTED /;"	d
CATCH_NULL	tests/catch.hpp	/^#   define CATCH_NULL /;"	d
CATCH_OVERRIDE	tests/catch.hpp	/^#   define CATCH_OVERRIDE /;"	d
CATCH_OVERRIDE	tests/catch.hpp	/^#   define CATCH_OVERRIDE$/;"	d
CATCH_PLATFORM_IPHONE	tests/catch.hpp	/^#define CATCH_PLATFORM_IPHONE$/;"	d
CATCH_PLATFORM_MAC	tests/catch.hpp	/^#define CATCH_PLATFORM_MAC$/;"	d
CATCH_PLATFORM_WINDOWS	tests/catch.hpp	/^#define CATCH_PLATFORM_WINDOWS$/;"	d
CATCH_REGISTER_LEGACY_REPORTER	tests/catch.hpp	/^#define CATCH_REGISTER_LEGACY_REPORTER(/;"	d
CATCH_REGISTER_REPORTER	tests/catch.hpp	/^#define CATCH_REGISTER_REPORTER(/;"	d
CATCH_REGISTER_TAG_ALIAS	tests/catch.hpp	/^#define CATCH_REGISTER_TAG_ALIAS(/;"	d
CATCH_REGISTER_TEST_CASE	tests/catch.hpp	/^    #define CATCH_REGISTER_TEST_CASE(/;"	d
CATCH_REQUIRE	tests/catch.hpp	/^                                                                                                /;"	d
CATCH_REQUIRE_FALSE	tests/catch.hpp	/^#define CATCH_REQUIRE_FALSE(/;"	d
CATCH_REQUIRE_NOTHROW	tests/catch.hpp	/^#define CATCH_REQUIRE_NOTHROW(/;"	d
CATCH_REQUIRE_THAT	tests/catch.hpp	/^#define CATCH_REQUIRE_THAT(/;"	d
CATCH_REQUIRE_THROWS	tests/catch.hpp	/^#define CATCH_REQUIRE_THROWS(/;"	d
CATCH_REQUIRE_THROWS_AS	tests/catch.hpp	/^#define CATCH_REQUIRE_THROWS_AS(/;"	d
CATCH_REQUIRE_THROWS_WITH	tests/catch.hpp	/^#define CATCH_REQUIRE_THROWS_WITH(/;"	d
CATCH_SCENARIO	tests/catch.hpp	/^#define CATCH_SCENARIO(/;"	d
CATCH_SCENARIO_METHOD	tests/catch.hpp	/^#define CATCH_SCENARIO_METHOD(/;"	d
CATCH_SCOPED_CAPTURE	tests/catch.hpp	/^#define CATCH_SCOPED_CAPTURE(/;"	d
CATCH_SCOPED_INFO	tests/catch.hpp	/^#define CATCH_SCOPED_INFO(/;"	d
CATCH_SECTION	tests/catch.hpp	/^    #define CATCH_SECTION(/;"	d
CATCH_SUCCEED	tests/catch.hpp	/^    #define CATCH_SUCCEED(/;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	tests/catch.hpp	/^#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH /;"	d
CATCH_TEST_CASE	tests/catch.hpp	/^    #define CATCH_TEST_CASE(/;"	d
CATCH_TEST_CASE_METHOD	tests/catch.hpp	/^    #define CATCH_TEST_CASE_METHOD(/;"	d
CATCH_THEN	tests/catch.hpp	/^#define CATCH_THEN(/;"	d
CATCH_TRANSLATE_EXCEPTION	tests/catch.hpp	/^#define CATCH_TRANSLATE_EXCEPTION(/;"	d
CATCH_UNSAFE_UNRETAINED	tests/catch.hpp	/^#define CATCH_UNSAFE_UNRETAINED /;"	d
CATCH_UNSAFE_UNRETAINED	tests/catch.hpp	/^#define CATCH_UNSAFE_UNRETAINED$/;"	d
CATCH_WARN	tests/catch.hpp	/^#define CATCH_WARN(/;"	d
CATCH_WHEN	tests/catch.hpp	/^#define CATCH_WHEN(/;"	d
CHECK	tests/catch.hpp	/^#define CHECK(/;"	d
CHECKED_ELSE	tests/catch.hpp	/^#define CHECKED_ELSE(/;"	d
CHECKED_IF	tests/catch.hpp	/^#define CHECKED_IF(/;"	d
CHECK_FALSE	tests/catch.hpp	/^#define CHECK_FALSE(/;"	d
CHECK_NOFAIL	tests/catch.hpp	/^#define CHECK_NOFAIL(/;"	d
CHECK_NOTHROW	tests/catch.hpp	/^#define CHECK_NOTHROW(/;"	d
CHECK_THAT	tests/catch.hpp	/^#define CHECK_THAT(/;"	d
CHECK_THROWS	tests/catch.hpp	/^#define CHECK_THROWS(/;"	d
CHECK_THROWS_AS	tests/catch.hpp	/^#define CHECK_THROWS_AS(/;"	d
CHECK_THROWS_WITH	tests/catch.hpp	/^#define CHECK_THROWS_WITH(/;"	d
CLARA_AUTO_PTR	tests/catch.hpp	/^#   define CLARA_AUTO_PTR(/;"	d
CLARA_CONFIG_CONSOLE_WIDTH	tests/catch.hpp	/^#define CLARA_CONFIG_CONSOLE_WIDTH /;"	d
CLARA_CONFIG_CPP11_GENERATED_METHODS	tests/catch.hpp	/^#define CLARA_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CLARA_CONFIG_CPP11_NOEXCEPT	tests/catch.hpp	/^#define CLARA_CONFIG_CPP11_NOEXCEPT$/;"	d
CLARA_CONFIG_CPP11_NULLPTR	tests/catch.hpp	/^#define CLARA_CONFIG_CPP11_NULLPTR$/;"	d
CLARA_CONFIG_CPP11_OVERRIDE	tests/catch.hpp	/^#define CLARA_CONFIG_CPP11_OVERRIDE$/;"	d
CLARA_CONFIG_CPP11_UNIQUE_PTR	tests/catch.hpp	/^#define CLARA_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CLARA_CONFIG_MAIN	tests/catch.hpp	/^#    define CLARA_CONFIG_MAIN$/;"	d
CLARA_CONFIG_MAIN_NOT_DEFINED	tests/catch.hpp	/^#    define CLARA_CONFIG_MAIN_NOT_DEFINED$/;"	d
CLARA_CPP11_OR_GREATER	tests/catch.hpp	/^#define CLARA_CPP11_OR_GREATER$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	tests/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	tests/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	tests/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE	tests/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	tests/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CLARA_NOEXCEPT	tests/catch.hpp	/^#define CLARA_NOEXCEPT /;"	d
CLARA_NOEXCEPT_IS	tests/catch.hpp	/^#  define CLARA_NOEXCEPT_IS(/;"	d
CLARA_NULL	tests/catch.hpp	/^#define CLARA_NULL /;"	d
CLARA_OVERRIDE	tests/catch.hpp	/^#define CLARA_OVERRIDE /;"	d
CLARA_OVERRIDE	tests/catch.hpp	/^#define CLARA_OVERRIDE$/;"	d
CLARA_PLATFORM_WINDOWS	tests/catch.hpp	/^#define CLARA_PLATFORM_WINDOWS$/;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	tests/catch.hpp	/^#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE /;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	tests/catch.hpp	/^namespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {$/;"	n
CaseSensitive	tests/catch.hpp	/^struct CaseSensitive {$/;"	s	namespace:Catch
CasedString	tests/catch.hpp	/^  CasedString(std::string const &str, CaseSensitive::Choice caseSensitivity)$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString
CasedString	tests/catch.hpp	/^struct CasedString {$/;"	s	namespace:Catch::Matchers::Impl::StdString
Catch	tests/catch.hpp	/^    namespace Catch {$/;"	n
Catch	tests/catch.hpp	/^    namespace Catch{$/;"	n
Catch	tests/catch.hpp	/^namespace Catch {$/;"	n
Catch	tests/catch.hpp	/^namespace Catch$/;"	n
ChildNodes	tests/catch.hpp	/^            typedef std::vector<Ptr<ChildNodeT> > ChildNodes;$/;"	t	struct:Catch::CumulativeReporterBase::Node	typeref:typename:std::vector<Ptr<ChildNodeT>>
ChildSections	tests/catch.hpp	/^            typedef std::vector<Ptr<SectionNode> > ChildSections;$/;"	t	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:std::vector<Ptr<SectionNode>>
Children	tests/catch.hpp	/^        typedef std::vector<Ptr<ITracker> > Children;$/;"	t	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:std::vector<Ptr<ITracker>>
Choice	tests/catch.hpp	/^  enum Choice {$/;"	g	struct:Catch::CaseSensitive
Clara	tests/catch.hpp	/^namespace Clara {$/;"	n
Code	tests/catch.hpp	/^        enum Code {$/;"	g	struct:Catch::Colour
Colour	tests/catch.hpp	/^    Colour::Colour( Code _colourCode ) : m_moved( false ) { use( _colourCode ); }$/;"	f	class:Catch::Colour
Colour	tests/catch.hpp	/^    Colour::Colour( Colour const& _other ) : m_moved( false ) { const_cast<Colour&>( _other ).m_/;"	f	class:Catch::Colour
Colour	tests/catch.hpp	/^    struct Colour {$/;"	s	namespace:Catch
CommandLine	tests/catch.hpp	/^        CommandLine( CommandLine const& other )$/;"	f	class:Clara::CommandLine
CommandLine	tests/catch.hpp	/^        CommandLine()$/;"	f	class:Clara::CommandLine
CommandLine	tests/catch.hpp	/^    class CommandLine {$/;"	c	namespace:Clara
CommonArgProperties	tests/catch.hpp	/^        CommonArgProperties( Detail::BoundArgFunction<ConfigT> const& _boundField ) : boundField/;"	f	struct:Clara::CommonArgProperties
CommonArgProperties	tests/catch.hpp	/^        CommonArgProperties() {}$/;"	f	struct:Clara::CommonArgProperties
CommonArgProperties	tests/catch.hpp	/^    struct CommonArgProperties {$/;"	s	namespace:Clara
CompactReporter	tests/catch.hpp	/^        CompactReporter( ReporterConfig const& _config )$/;"	f	struct:Catch::CompactReporter
CompactReporter	tests/catch.hpp	/^    struct CompactReporter : StreamingReporterBase {$/;"	s	namespace:Catch
CompletedCycle	tests/catch.hpp	/^            CompletedCycle$/;"	e	enum:Catch::TestCaseTracking::TrackerContext::RunState
CompletedSuccessfully	tests/catch.hpp	/^            CompletedSuccessfully,$/;"	e	enum:Catch::TestCaseTracking::TrackerBase::CycleState
CompositeGenerator	tests/catch.hpp	/^  CompositeGenerator() : m_totalSize(0) {}$/;"	f	class:Catch::CompositeGenerator
CompositeGenerator	tests/catch.hpp	/^  CompositeGenerator(CompositeGenerator &other)$/;"	f	class:Catch::CompositeGenerator
CompositeGenerator	tests/catch.hpp	/^class CompositeGenerator {$/;"	c	namespace:Catch
Config	tests/catch.hpp	/^        Config( ConfigData const& data )$/;"	f	class:Catch::Config
Config	tests/catch.hpp	/^        Config()$/;"	f	class:Catch::Config
Config	tests/catch.hpp	/^    class Config : public SharedImpl<IConfig> {$/;"	c	namespace:Catch
ConfigData	tests/catch.hpp	/^        ConfigData()$/;"	f	struct:Catch::ConfigData
ConfigData	tests/catch.hpp	/^    struct ConfigData {$/;"	s	namespace:Catch
ConsoleReporter	tests/catch.hpp	/^        ConsoleReporter( ReporterConfig const& _config )$/;"	f	struct:Catch::ConsoleReporter
ConsoleReporter	tests/catch.hpp	/^    struct ConsoleReporter : StreamingReporterBase {$/;"	s	namespace:Catch
Contains	tests/catch.hpp	/^                Contains( NSString* substr ) : StringHolder( substr ){}$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::Contains
Contains	tests/catch.hpp	/^            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::NSStringMatchers::Contains
Contains	tests/catch.hpp	/^            struct Contains : StringHolder<Contains> {$/;"	s	namespace:Catch::Matchers::Impl::NSStringMatchers
Contains	tests/catch.hpp	/^  Contains(Contains const &other) : m_data(other.m_data) {}$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains
Contains	tests/catch.hpp	/^  Contains(std::string const &substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes/;"	f	struct:Catch::Matchers::Impl::StdString::Contains
Contains	tests/catch.hpp	/^inline Impl::StdString::Contains Contains(const char *substr,$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::Contains
Contains	tests/catch.hpp	/^inline Impl::StdString::Contains Contains(std::string const &substr,$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::Contains
Contains	tests/catch.hpp	/^struct Contains : MatcherImpl<Contains, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString
Context	tests/catch.hpp	/^        Context() : m_config( CATCH_NULL ), m_runner( CATCH_NULL ), m_resultCapture( CATCH_NULL /;"	f	class:Catch::Context
Context	tests/catch.hpp	/^    class Context : public IMutableContext {$/;"	c	namespace:Catch
ContinueOnFailure	tests/catch.hpp	/^    ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
CopyableStream	tests/catch.hpp	/^  CopyableStream() {}$/;"	f	struct:Catch::CopyableStream
CopyableStream	tests/catch.hpp	/^  CopyableStream(CopyableStream const &other) {$/;"	f	struct:Catch::CopyableStream
CopyableStream	tests/catch.hpp	/^struct CopyableStream {$/;"	s	namespace:Catch
Counts	tests/catch.hpp	/^  Counts() : passed(0), failed(0), failedButOk(0) {}$/;"	f	struct:Catch::Counts
Counts	tests/catch.hpp	/^struct Counts {$/;"	s	namespace:Catch
CoutStream	tests/catch.hpp	/^    CoutStream::CoutStream()$/;"	f	class:Catch::CoutStream
CoutStream	tests/catch.hpp	/^    class CoutStream : public IStream {$/;"	c	namespace:Catch
CumulativeReporterBase	tests/catch.hpp	/^        CumulativeReporterBase( ReporterConfig const& _config )$/;"	f	struct:Catch::CumulativeReporterBase
CumulativeReporterBase	tests/catch.hpp	/^    struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {$/;"	s	namespace:Catch
Cyan	tests/catch.hpp	/^            Cyan,$/;"	e	enum:Catch::Colour::Code
CycleState	tests/catch.hpp	/^        enum CycleState {$/;"	g	class:Catch::TestCaseTracking::TrackerBase
DONTNEED	file.h	/^    DONTNEED = POSIX_FADV_DONTNEED$/;"	e	enum:File::ACCESS_ADVICE
DebugOutStream	tests/catch.hpp	/^    DebugOutStream::DebugOutStream()$/;"	f	class:Catch::DebugOutStream
DebugOutStream	tests/catch.hpp	/^    class DebugOutStream : public IStream {$/;"	c	namespace:Catch
DefaultForReporter	tests/catch.hpp	/^        DefaultForReporter,$/;"	e	enum:Catch::ShowDurations::OrNot
Detail	tests/catch.hpp	/^    namespace Detail {$/;"	n	namespace:Clara
Detail	tests/catch.hpp	/^    namespace Detail{$/;"	n	namespace:Catch
Detail	tests/catch.hpp	/^namespace Detail {$/;"	n	namespace:Catch
DidntThrowException	tests/catch.hpp	/^    DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
DoWhat	tests/catch.hpp	/^        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };$/;"	g	struct:Catch::Session::OnUnusedOptions
END_OF_FILE	file.h	/^    END_OF_FILE$/;"	e	enum:File::READ_STATUS
ERROR	file.h	/^    ERROR,$/;"	e	enum:File::READ_STATUS
ERROR	file.h	/^    ERROR,$/;"	e	enum:File::STATUS
ElementPrinter	tests/catch.hpp	/^  struct ElementPrinter {$/;"	s	namespace:Catch::TupleDetail
ElementPrinter	tests/catch.hpp	/^  struct ElementPrinter<Tuple,N,false> {$/;"	s	namespace:Catch::TupleDetail
Endianness	tests/catch.hpp	/^        struct Endianness {$/;"	s	namespace:Catch::Detail::__anond33fe2000810
EndsWith	tests/catch.hpp	/^                EndsWith( NSString* substr ) : StringHolder( substr ){}$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::EndsWith
EndsWith	tests/catch.hpp	/^            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::NSStringMatchers::EndsWith
EndsWith	tests/catch.hpp	/^            struct EndsWith : StringHolder<EndsWith> {$/;"	s	namespace:Catch::Matchers::Impl::NSStringMatchers
EndsWith	tests/catch.hpp	/^  EndsWith(EndsWith const &other) : m_data(other.m_data) {}$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith
EndsWith	tests/catch.hpp	/^  EndsWith(std::string const &substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith
EndsWith	tests/catch.hpp	/^inline Impl::StdString::EndsWith EndsWith(const char *substr) {$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::EndsWith
EndsWith	tests/catch.hpp	/^inline Impl::StdString::EndsWith EndsWith(std::string const &substr) {$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::EndsWith
EndsWith	tests/catch.hpp	/^struct EndsWith : MatcherImpl<EndsWith, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString
EnumStringMaker	tests/catch.hpp	/^    struct EnumStringMaker$/;"	s	namespace:Catch::Detail
EnumStringMaker	tests/catch.hpp	/^    struct EnumStringMaker<T,true>$/;"	s	namespace:Catch::Detail
Equals	tests/catch.hpp	/^                Equals( NSString* substr ) : StringHolder( substr ){}$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::Equals
Equals	tests/catch.hpp	/^            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::NSStringMatchers::Equals
Equals	tests/catch.hpp	/^            struct Equals : StringHolder<Equals> {$/;"	s	namespace:Catch::Matchers::Impl::NSStringMatchers
Equals	tests/catch.hpp	/^  Equals(Equals const &other) : m_data(other.m_data) {}$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals
Equals	tests/catch.hpp	/^  Equals(std::string const &str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals
Equals	tests/catch.hpp	/^inline Impl::StdString::Equals Equals(const char *str, CaseSensitive::Choice caseSensitivity = C/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::Equals
Equals	tests/catch.hpp	/^inline Impl::StdString::Equals Equals(std::string const &str,$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::Equals
Equals	tests/catch.hpp	/^struct Equals : MatcherImpl<Equals, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString
Error	tests/catch.hpp	/^            Error = BrightRed,$/;"	e	enum:Catch::Colour::Code
Evaluator	tests/catch.hpp	/^class Evaluator {};$/;"	c	namespace:Catch::Internal
Evaluator	tests/catch.hpp	/^struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	tests/catch.hpp	/^struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Evaluator	tests/catch.hpp	/^struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	tests/catch.hpp	/^struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Evaluator	tests/catch.hpp	/^struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	tests/catch.hpp	/^struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Exception	tests/catch.hpp	/^    Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
ExceptionTranslator	tests/catch.hpp	/^    ExceptionTranslator(std::string(*translateFunction)(T &))$/;"	f	class:Catch::ExceptionTranslatorRegistrar::ExceptionTranslator
ExceptionTranslator	tests/catch.hpp	/^  class ExceptionTranslator : public IExceptionTranslator {$/;"	c	class:Catch::ExceptionTranslatorRegistrar
ExceptionTranslatorRegistrar	tests/catch.hpp	/^  ExceptionTranslatorRegistrar(std::string(*translateFunction)(T &)) {$/;"	f	class:Catch::ExceptionTranslatorRegistrar
ExceptionTranslatorRegistrar	tests/catch.hpp	/^class ExceptionTranslatorRegistrar {$/;"	c	namespace:Catch
ExceptionTranslatorRegistry	tests/catch.hpp	/^    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {$/;"	c	namespace:Catch
ExceptionTranslators	tests/catch.hpp	/^typedef std::vector<const IExceptionTranslator *> ExceptionTranslators;$/;"	t	namespace:Catch	typeref:typename:std::vector<const IExceptionTranslator * >
ExcludedPattern	tests/catch.hpp	/^            ExcludedPattern( Ptr<Pattern> const& underlyingPattern ) : m_underlyingPattern( unde/;"	f	class:Catch::TestSpec::ExcludedPattern
ExcludedPattern	tests/catch.hpp	/^        class ExcludedPattern : public Pattern {$/;"	c	class:Catch::TestSpec
Executing	tests/catch.hpp	/^            Executing,$/;"	e	enum:Catch::TestCaseTracking::TrackerBase::CycleState
Executing	tests/catch.hpp	/^            Executing,$/;"	e	enum:Catch::TestCaseTracking::TrackerContext::RunState
ExecutingChildren	tests/catch.hpp	/^            ExecutingChildren,$/;"	e	enum:Catch::TestCaseTracking::TrackerBase::CycleState
ExplicitFailure	tests/catch.hpp	/^    ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
ExprComponents	tests/catch.hpp	/^    ExprComponents() : testFalse(false) {}$/;"	f	struct:Catch::ResultBuilder::ExprComponents
ExprComponents	tests/catch.hpp	/^  struct ExprComponents {$/;"	s	class:Catch::ResultBuilder
ExpressionFailed	tests/catch.hpp	/^    ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
ExpressionLhs	tests/catch.hpp	/^  ExpressionLhs(ResultBuilder &rb, T lhs) : m_rb(rb), m_lhs(lhs) {}$/;"	f	class:Catch::ExpressionLhs
ExpressionLhs	tests/catch.hpp	/^class ExpressionLhs {$/;"	c	namespace:Catch
ExpressionType	tests/catch.hpp	/^  typedef ExpressionT ExpressionType;$/;"	t	struct:Catch::Matchers::Impl::Matcher	typeref:typename:ExpressionT
FAIL	tests/catch.hpp	/^    #define FAIL(/;"	d
FAIL	tests/catch.hpp	/^#define FAIL(/;"	d
FactoryMap	tests/catch.hpp	/^        typedef std::map<std::string, Ptr<IReporterFactory> > FactoryMap;$/;"	t	struct:Catch::IReporterRegistry	typeref:typename:std::map<std::string,Ptr<IReporterFactory>>
Fail	tests/catch.hpp	/^        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };$/;"	e	enum:Catch::Session::OnUnusedOptions::DoWhat
Failed	tests/catch.hpp	/^            Failed$/;"	e	enum:Catch::TestCaseTracking::TrackerBase::CycleState
FailureBit	tests/catch.hpp	/^    FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
FalseTest	tests/catch.hpp	/^    FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
FalseType	tests/catch.hpp	/^struct FalseType { char sizer[2]; };$/;"	s	namespace:Catch::Detail
FatalConditionHandler	tests/catch.hpp	/^        FatalConditionHandler() : m_isSet( true ) {$/;"	f	struct:Catch::FatalConditionHandler
FatalConditionHandler	tests/catch.hpp	/^    struct FatalConditionHandler {$/;"	s	namespace:Catch
FatalErrorCondition	tests/catch.hpp	/^    FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
File	file.cpp	/^File::File() :$/;"	f	class:File
File	file.h	/^class File {$/;"	c
FileName	tests/catch.hpp	/^            FileName = LightGrey,$/;"	e	enum:Catch::Colour::Code
FileStream	tests/catch.hpp	/^    FileStream::FileStream( std::string const& filename ) {$/;"	f	class:Catch::FileStream
FileStream	tests/catch.hpp	/^    class FileStream : public IStream {$/;"	c	namespace:Catch
Filter	tests/catch.hpp	/^        struct Filter {$/;"	s	class:Catch::TestSpec
Flags	tests/catch.hpp	/^  enum Flags {$/;"	g	struct:Catch::ResultDisposition
ForAttributes	tests/catch.hpp	/^        enum ForWhat { ForTextNodes, ForAttributes };$/;"	e	enum:Catch::XmlEncode::ForWhat
ForTextNodes	tests/catch.hpp	/^        enum ForWhat { ForTextNodes, ForAttributes };$/;"	e	enum:Catch::XmlEncode::ForWhat
ForWhat	tests/catch.hpp	/^        enum ForWhat { ForTextNodes, ForAttributes };$/;"	g	class:Catch::XmlEncode
FreeFunctionTestCase	tests/catch.hpp	/^        FreeFunctionTestCase( TestFunction fun ) : m_fun( fun ) {}$/;"	f	class:Catch::FreeFunctionTestCase
FreeFunctionTestCase	tests/catch.hpp	/^    class FreeFunctionTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch
GENERATE	tests/catch.hpp	/^#define GENERATE(/;"	d
GIVEN	tests/catch.hpp	/^#define GIVEN(/;"	d
GeneratorInfo	tests/catch.hpp	/^        GeneratorInfo( std::size_t size )$/;"	f	struct:Catch::GeneratorInfo
GeneratorInfo	tests/catch.hpp	/^    struct GeneratorInfo : IGeneratorInfo {$/;"	s	namespace:Catch
Generators	tests/catch.hpp	/^namespace Generators {$/;"	n	namespace:Catch
GeneratorsForTest	tests/catch.hpp	/^    class GeneratorsForTest : public IGeneratorsForTest {$/;"	c	namespace:Catch
Generic	tests/catch.hpp	/^namespace Generic {$/;"	n	namespace:Catch::Matchers::Impl
Get	file.cpp	/^const std::string &File::Get() const {$/;"	f	class:File	typeref:typename:const std::string &
Green	tests/catch.hpp	/^            Green,$/;"	e	enum:Catch::Colour::Code
Grey	tests/catch.hpp	/^            Grey,$/;"	e	enum:Catch::Colour::Code
GroupInfo	tests/catch.hpp	/^        GroupInfo(  std::string const& _name,$/;"	f	struct:Catch::GroupInfo
GroupInfo	tests/catch.hpp	/^    struct GroupInfo {$/;"	s	namespace:Catch
Headers	tests/catch.hpp	/^            Headers = White$/;"	e	enum:Catch::Colour::Code
IArgFunction	tests/catch.hpp	/^        struct IArgFunction {$/;"	s	namespace:Clara::Detail
IColourImpl	tests/catch.hpp	/^        struct IColourImpl {$/;"	s	namespace:Catch::__anond33fe2000410
IConfig	tests/catch.hpp	/^    struct IConfig : IShared {$/;"	s	namespace:Catch
IContext	tests/catch.hpp	/^struct IContext {$/;"	s	namespace:Catch
IExceptionTranslator	tests/catch.hpp	/^struct IExceptionTranslator {$/;"	s	namespace:Catch
IExceptionTranslatorRegistry	tests/catch.hpp	/^struct IExceptionTranslatorRegistry {$/;"	s	namespace:Catch
IGenerator	tests/catch.hpp	/^struct IGenerator {$/;"	s	namespace:Catch
IGeneratorInfo	tests/catch.hpp	/^struct IGeneratorInfo {$/;"	s	namespace:Catch
IGeneratorsForTest	tests/catch.hpp	/^struct IGeneratorsForTest {$/;"	s	namespace:Catch
IMutableContext	tests/catch.hpp	/^struct IMutableContext : IContext {$/;"	s	namespace:Catch
IMutableRegistryHub	tests/catch.hpp	/^struct IMutableRegistryHub {$/;"	s	namespace:Catch
INFO	tests/catch.hpp	/^#define INFO(/;"	d
INTERNAL_CATCH_ELSE	tests/catch.hpp	/^#define INTERNAL_CATCH_ELSE(/;"	d
INTERNAL_CATCH_GENERATE	tests/catch.hpp	/^#define INTERNAL_CATCH_GENERATE(/;"	d
INTERNAL_CATCH_IF	tests/catch.hpp	/^#define INTERNAL_CATCH_IF(/;"	d
INTERNAL_CATCH_INFO	tests/catch.hpp	/^#define INTERNAL_CATCH_INFO(/;"	d
INTERNAL_CATCH_LINESTR	tests/catch.hpp	/^#define INTERNAL_CATCH_LINESTR(/;"	d
INTERNAL_CATCH_LINESTR2	tests/catch.hpp	/^#define INTERNAL_CATCH_LINESTR2(/;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	tests/catch.hpp	/^    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE(/;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	tests/catch.hpp	/^#define INTERNAL_CATCH_METHOD_AS_TEST_CASE(/;"	d
INTERNAL_CATCH_MSG	tests/catch.hpp	/^                                                                                                /;"	d
INTERNAL_CATCH_MSG	tests/catch.hpp	/^#define INTERNAL_CATCH_MSG(/;"	d
INTERNAL_CATCH_NO_THROW	tests/catch.hpp	/^#define INTERNAL_CATCH_NO_THROW(/;"	d
INTERNAL_CATCH_REACT	tests/catch.hpp	/^#define INTERNAL_CATCH_REACT(/;"	d
INTERNAL_CATCH_REGISTER_LEGACY_REPORTER	tests/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER(/;"	d
INTERNAL_CATCH_REGISTER_LISTENER	tests/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_LISTENER(/;"	d
INTERNAL_CATCH_REGISTER_REPORTER	tests/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_REPORTER(/;"	d
INTERNAL_CATCH_REGISTER_TESTCASE	tests/catch.hpp	/^    #define INTERNAL_CATCH_REGISTER_TESTCASE(/;"	d
INTERNAL_CATCH_REGISTER_TESTCASE	tests/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_TESTCASE(/;"	d
INTERNAL_CATCH_SECTION	tests/catch.hpp	/^                                                                                                /;"	d
INTERNAL_CATCH_SECTION	tests/catch.hpp	/^#define INTERNAL_CATCH_SECTION(/;"	d
INTERNAL_CATCH_STRINGIFY	tests/catch.hpp	/^#define INTERNAL_CATCH_STRINGIFY(/;"	d
INTERNAL_CATCH_STRINGIFY2	tests/catch.hpp	/^#define INTERNAL_CATCH_STRINGIFY2(/;"	d
INTERNAL_CATCH_TEST	tests/catch.hpp	/^#define INTERNAL_CATCH_TEST(/;"	d
INTERNAL_CATCH_TESTCASE	tests/catch.hpp	/^    #define INTERNAL_CATCH_TESTCASE(/;"	d
INTERNAL_CATCH_TESTCASE	tests/catch.hpp	/^#define INTERNAL_CATCH_TESTCASE(/;"	d
INTERNAL_CATCH_TESTCASE2	tests/catch.hpp	/^    #define INTERNAL_CATCH_TESTCASE2(/;"	d
INTERNAL_CATCH_TESTCASE2	tests/catch.hpp	/^#define INTERNAL_CATCH_TESTCASE2(/;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	tests/catch.hpp	/^    #define INTERNAL_CATCH_TEST_CASE_METHOD(/;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	tests/catch.hpp	/^#define INTERNAL_CATCH_TEST_CASE_METHOD(/;"	d
INTERNAL_CATCH_TEST_CASE_METHOD2	tests/catch.hpp	/^    #define INTERNAL_CATCH_TEST_CASE_METHOD2(/;"	d
INTERNAL_CATCH_TEST_CASE_METHOD2	tests/catch.hpp	/^#define INTERNAL_CATCH_TEST_CASE_METHOD2(/;"	d
INTERNAL_CATCH_THROWS	tests/catch.hpp	/^#define INTERNAL_CATCH_THROWS(/;"	d
INTERNAL_CATCH_THROWS_AS	tests/catch.hpp	/^#define INTERNAL_CATCH_THROWS_AS(/;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION	tests/catch.hpp	/^#define INTERNAL_CATCH_TRANSLATE_EXCEPTION(/;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION2	tests/catch.hpp	/^#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2(/;"	d
INTERNAL_CATCH_UNIQUE_NAME	tests/catch.hpp	/^#  define INTERNAL_CATCH_UNIQUE_NAME(/;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE	tests/catch.hpp	/^#define INTERNAL_CATCH_UNIQUE_NAME_LINE(/;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE2	tests/catch.hpp	/^#define INTERNAL_CATCH_UNIQUE_NAME_LINE2(/;"	d
INTERNAL_CHECK_THAT	tests/catch.hpp	/^#define INTERNAL_CHECK_THAT(/;"	d
IRegistryHub	tests/catch.hpp	/^struct IRegistryHub {$/;"	s	namespace:Catch
IReporter	tests/catch.hpp	/^    struct IReporter : IShared {$/;"	s	namespace:Catch
IReporterFactory	tests/catch.hpp	/^    struct IReporterFactory : IShared {$/;"	s	namespace:Catch
IReporterRegistry	tests/catch.hpp	/^    struct IReporterRegistry {$/;"	s	namespace:Catch
IResultCapture	tests/catch.hpp	/^struct IResultCapture {$/;"	s	namespace:Catch
IRunner	tests/catch.hpp	/^struct IRunner {$/;"	s	namespace:Catch
IShared	tests/catch.hpp	/^struct IShared : NonCopyable {$/;"	s	namespace:Catch
IStream	tests/catch.hpp	/^    struct IStream {$/;"	s	namespace:Catch
IStreamingReporter	tests/catch.hpp	/^    struct IStreamingReporter : IShared {$/;"	s	namespace:Catch
ITagAliasRegistry	tests/catch.hpp	/^struct ITagAliasRegistry {$/;"	s	namespace:Catch
ITestCase	tests/catch.hpp	/^struct ITestCase : IShared {$/;"	s	namespace:Catch
ITestCaseRegistry	tests/catch.hpp	/^struct ITestCaseRegistry {$/;"	s	namespace:Catch
ITracker	tests/catch.hpp	/^    struct ITracker : SharedImpl<> {$/;"	s	namespace:Catch::TestCaseTracking
Ignore	tests/catch.hpp	/^        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };$/;"	e	enum:Catch::Session::OnUnusedOptions::DoWhat
Impl	tests/catch.hpp	/^        namespace Impl {$/;"	n	namespace:Catch::Matchers
Impl	tests/catch.hpp	/^namespace Impl {$/;"	n	namespace:Catch::Matchers
InDeclarationOrder	tests/catch.hpp	/^        InDeclarationOrder,$/;"	e	enum:Catch::RunTests::InWhatOrder
InLexicographicalOrder	tests/catch.hpp	/^        InLexicographicalOrder,$/;"	e	enum:Catch::RunTests::InWhatOrder
InRandomOrder	tests/catch.hpp	/^        InRandomOrder$/;"	e	enum:Catch::RunTests::InWhatOrder
InWhatOrder	tests/catch.hpp	/^    struct RunTests { enum InWhatOrder {$/;"	g	struct:Catch::RunTests
IndexTracker	tests/catch.hpp	/^        IndexTracker( std::string const& name, TrackerContext& ctx, ITracker* parent, int size )$/;"	f	class:Catch::TestCaseTracking::IndexTracker
IndexTracker	tests/catch.hpp	/^    class IndexTracker : public TrackerBase {$/;"	c	namespace:Catch::TestCaseTracking
Info	tests/catch.hpp	/^    Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Internal	tests/catch.hpp	/^namespace Internal {$/;"	n	namespace:Catch
IsBool	tests/catch.hpp	/^        template<>              struct IsBool<bool> { static const bool value = true; };$/;"	s	namespace:Clara::Detail
IsBool	tests/catch.hpp	/^        template<typename T>    struct IsBool       { static const bool value = false; };$/;"	s	namespace:Clara::Detail
IsEqualTo	tests/catch.hpp	/^  IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThan	tests/catch.hpp	/^  IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThanOrEqualTo	tests/catch.hpp	/^  IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
IsHidden	tests/catch.hpp	/^    IsHidden = 1 << 1,$/;"	e	enum:Catch::TestCaseInfo::SpecialProperties
IsLessThan	tests/catch.hpp	/^  IsLessThan,$/;"	e	enum:Catch::Internal::Operator
IsLessThanOrEqualTo	tests/catch.hpp	/^  IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsNotEqualTo	tests/catch.hpp	/^  IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsStreamInsertable	tests/catch.hpp	/^struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
JunitReporter	tests/catch.hpp	/^        JunitReporter( ReporterConfig const& _config )$/;"	f	class:Catch::JunitReporter
JunitReporter	tests/catch.hpp	/^    class JunitReporter : public CumulativeReporterBase {$/;"	c	namespace:Catch
LazyStat	tests/catch.hpp	/^        LazyStat() : used( false ) {}$/;"	f	struct:Catch::LazyStat
LazyStat	tests/catch.hpp	/^    struct LazyStat : Option<T> {$/;"	s	namespace:Catch
LegacyReporterAdapter	tests/catch.hpp	/^    LegacyReporterAdapter::LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter )$/;"	f	class:Catch::LegacyReporterAdapter
LegacyReporterAdapter	tests/catch.hpp	/^    class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>$/;"	c	namespace:Catch
LegacyReporterRegistrar	tests/catch.hpp	/^        LegacyReporterRegistrar( std::string const& name ) {$/;"	f	class:Catch::LegacyReporterRegistrar
LegacyReporterRegistrar	tests/catch.hpp	/^    class LegacyReporterRegistrar {$/;"	c	namespace:Catch
Level	tests/catch.hpp	/^    struct Verbosity { enum Level {$/;"	g	struct:Catch::Verbosity
LexSort	tests/catch.hpp	/^    struct LexSort {$/;"	s	namespace:Catch
LightGrey	tests/catch.hpp	/^            LightGrey = Bright | Grey,$/;"	e	enum:Catch::Colour::Code
ListenerFactory	tests/catch.hpp	/^        class ListenerFactory : public SharedImpl<IReporterFactory> {$/;"	c	class:Catch::ListenerRegistrar
ListenerRegistrar	tests/catch.hpp	/^        ListenerRegistrar() {$/;"	f	class:Catch::ListenerRegistrar
ListenerRegistrar	tests/catch.hpp	/^    class ListenerRegistrar {$/;"	c	namespace:Catch
Listeners	tests/catch.hpp	/^        typedef std::vector<Ptr<IReporterFactory> > Listeners;$/;"	t	struct:Catch::IReporterRegistry	typeref:typename:std::vector<Ptr<IReporterFactory>>
Little	tests/catch.hpp	/^            enum Arch { Big, Little };$/;"	e	enum:Catch::Detail::__anond33fe2000810::Endianness::Arch
LongOpt	tests/catch.hpp	/^            enum Type { Positional, ShortOpt, LongOpt };$/;"	e	enum:Clara::Parser::Token::Type
LongOpt	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	e	enum:Clara::Parser::Mode
METHOD_AS_TEST_CASE	tests/catch.hpp	/^    #define METHOD_AS_TEST_CASE(/;"	d
METHOD_AS_TEST_CASE	tests/catch.hpp	/^#define METHOD_AS_TEST_CASE(/;"	d
Matcher	tests/catch.hpp	/^struct Matcher : SharedImpl<IShared> {$/;"	s	namespace:Catch::Matchers::Impl
MatcherImpl	tests/catch.hpp	/^struct MatcherImpl : Matcher<ExpressionT> {$/;"	s	namespace:Catch::Matchers::Impl
Matchers	tests/catch.hpp	/^    namespace Matchers {$/;"	n	namespace:Catch
Matchers	tests/catch.hpp	/^namespace Matchers {$/;"	n	namespace:Catch
MayFail	tests/catch.hpp	/^    MayFail = 1 << 3,$/;"	e	enum:Catch::TestCaseInfo::SpecialProperties
MaybeShortOpt	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	e	enum:Clara::Parser::Mode
MessageBuilder	tests/catch.hpp	/^  MessageBuilder(std::string const &macroName,$/;"	f	struct:Catch::MessageBuilder
MessageBuilder	tests/catch.hpp	/^struct MessageBuilder {$/;"	s	namespace:Catch
MessageInfo	tests/catch.hpp	/^    MessageInfo::MessageInfo(   std::string const& _macroName,$/;"	f	class:Catch::MessageInfo
MessageInfo	tests/catch.hpp	/^struct MessageInfo {$/;"	s	namespace:Catch
MethodTestCase	tests/catch.hpp	/^  MethodTestCase(void (C::*method)()) : m_method(method) {}$/;"	f	class:Catch::MethodTestCase
MethodTestCase	tests/catch.hpp	/^class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch
Mode	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	g	class:Clara::Parser
Mode	tests/catch.hpp	/^        enum Mode{ None, Name, QuotedName, Tag };$/;"	g	class:Catch::TestSpecParser
MultipleReporters	tests/catch.hpp	/^class MultipleReporters : public SharedImpl<IStreamingReporter> {$/;"	c	namespace:Catch
NOMINMAX	tests/catch.hpp	/^#define NOMINMAX$/;"	d
NOREUSE	file.h	/^    NOREUSE = POSIX_FADV_NOREUSE,$/;"	e	enum:File::ACCESS_ADVICE
NORMAL	file.h	/^    NORMAL = POSIX_FADV_NORMAL,$/;"	e	enum:File::ACCESS_ADVICE
NOT_FOUND	file.h	/^    NOT_FOUND$/;"	e	enum:File::STATUS
NSStringMatchers	tests/catch.hpp	/^        namespace NSStringMatchers {$/;"	n	namespace:Catch::Matchers::Impl
Name	tests/catch.hpp	/^        enum Mode{ None, Name, QuotedName, Tag };$/;"	e	enum:Catch::TestSpecParser::Mode
NameAndDesc	tests/catch.hpp	/^  NameAndDesc(const char *_name = "", const char *_description = "")$/;"	f	struct:Catch::NameAndDesc
NameAndDesc	tests/catch.hpp	/^struct NameAndDesc {$/;"	s	namespace:Catch
NamePattern	tests/catch.hpp	/^            NamePattern( std::string const& name )$/;"	f	class:Catch::TestSpec::NamePattern
NamePattern	tests/catch.hpp	/^        class NamePattern : public Pattern {$/;"	c	class:Catch::TestSpec
NeedsAnotherRun	tests/catch.hpp	/^            NeedsAnotherRun,$/;"	e	enum:Catch::TestCaseTracking::TrackerBase::CycleState
Never	tests/catch.hpp	/^        Never$/;"	e	enum:Catch::ShowDurations::OrNot
No	tests/catch.hpp	/^        No$/;"	e	enum:Catch::UseColour::YesOrNo
No	tests/catch.hpp	/^    No$/;"	e	enum:Catch::CaseSensitive::Choice
NoAssertions	tests/catch.hpp	/^        NoAssertions = 0x01$/;"	e	enum:Catch::WarnAbout::What
NoColourImpl	tests/catch.hpp	/^        struct NoColourImpl : IColourImpl {$/;"	s	namespace:Catch::__anond33fe2000410
NoOutput	tests/catch.hpp	/^        NoOutput = 0,$/;"	e	enum:Catch::Verbosity::Level
NoWildcard	tests/catch.hpp	/^            NoWildcard = 0,$/;"	e	enum:Catch::WildcardPattern::WildcardPosition
Node	tests/catch.hpp	/^            explicit Node( T const& _value ) : value( _value ) {}$/;"	f	struct:Catch::CumulativeReporterBase::Node
Node	tests/catch.hpp	/^        struct Node : SharedImpl<> {$/;"	s	struct:Catch::CumulativeReporterBase
NonCopyable	tests/catch.hpp	/^  NonCopyable() {}$/;"	f	class:Catch::NonCopyable
NonCopyable	tests/catch.hpp	/^class NonCopyable {$/;"	c	namespace:Catch
None	tests/catch.hpp	/^            None = 0,$/;"	e	enum:Catch::Colour::Code
None	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	e	enum:Clara::Parser::Mode
None	tests/catch.hpp	/^        enum Mode{ None, Name, QuotedName, Tag };$/;"	e	enum:Catch::TestSpecParser::Mode
None	tests/catch.hpp	/^    None = 0,$/;"	e	enum:Catch::TestCaseInfo::SpecialProperties
Normal	tests/catch.hpp	/^        Normal$/;"	e	enum:Catch::Verbosity::Level
Normal	tests/catch.hpp	/^    Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Not	tests/catch.hpp	/^  Not(Not const &other) : m_matcher(other.m_matcher) {}$/;"	f	class:Catch::Matchers::Impl::Generic::Not
Not	tests/catch.hpp	/^  explicit Not(Matcher<ExpressionT> const &matcher) : m_matcher(matcher.clone()) {}$/;"	f	class:Catch::Matchers::Impl::Generic::Not
Not	tests/catch.hpp	/^class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {$/;"	c	namespace:Catch::Matchers::Impl::Generic
Not	tests/catch.hpp	/^inline Impl::Generic::Not<ExpressionT> Not(Impl::Matcher<ExpressionT> const &m) {$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::Generic::Not<ExpressionT>
NotImplementedException	tests/catch.hpp	/^    NotImplementedException::NotImplementedException( SourceLineInfo const& lineInfo )$/;"	f	class:Catch::NotImplementedException
NotImplementedException	tests/catch.hpp	/^  NotImplementedException(NotImplementedException const &) {}$/;"	f	class:Catch::NotImplementedException
NotImplementedException	tests/catch.hpp	/^class NotImplementedException : public std::exception {$/;"	c	namespace:Catch
NotStarted	tests/catch.hpp	/^            NotStarted,$/;"	e	enum:Catch::TestCaseTracking::TrackerBase::CycleState
NotStarted	tests/catch.hpp	/^            NotStarted,$/;"	e	enum:Catch::TestCaseTracking::TrackerContext::RunState
Nothing	tests/catch.hpp	/^        Nothing = 0x00,$/;"	e	enum:Catch::WarnAbout::What
NullBinder	tests/catch.hpp	/^        struct NullBinder : IArgFunction<C>{$/;"	s	namespace:Clara::Detail
OC_TEST_CASE	tests/catch.hpp	/^#define OC_TEST_CASE(/;"	d
OK	file.h	/^    OK = 0,$/;"	e	enum:File::READ_STATUS
OK	file.h	/^    OK = 0,$/;"	e	enum:File::STATUS
OcMethod	tests/catch.hpp	/^        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}$/;"	f	class:Catch::OcMethod
OcMethod	tests/catch.hpp	/^    class OcMethod : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch
OfType	tests/catch.hpp	/^  enum OfType {$/;"	g	struct:Catch::ResultWas
Ok	file.cpp	/^bool File::Ok() const {$/;"	f	class:File	typeref:typename:bool
Ok	tests/catch.hpp	/^    Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
OnUnusedOptions	tests/catch.hpp	/^        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };$/;"	s	class:Catch::Session
Open	file.cpp	/^File::STATUS File::Open(const char * path) {$/;"	f	class:File	typeref:typename:File::STATUS
Open	file.cpp	/^File::STATUS File::Open(const std::string & path) {$/;"	f	class:File	typeref:typename:File::STATUS
Operator	tests/catch.hpp	/^enum Operator {$/;"	g	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits { static const char *getName() { return "*error*"; }};$/;"	s	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits<IsEqualTo> { static const char *getName() { return "=="; }};$/;"	s	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits<IsGreaterThan> { static const char *getName() { return ">"; }};$/;"	s	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits<IsGreaterThanOrEqualTo> { static const char *getName() { return ">="; }};$/;"	s	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits<IsLessThan> { static const char *getName() { return "<"; }};$/;"	s	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits<IsLessThanOrEqualTo> { static const char *getName() { return "<="; }};$/;"	s	namespace:Catch::Internal
OperatorTraits	tests/catch.hpp	/^struct OperatorTraits<IsNotEqualTo> { static const char *getName() { return "!="; }};$/;"	s	namespace:Catch::Internal
OptBuilder	tests/catch.hpp	/^            OptBuilder( Arg* arg ) : ArgBuilder( arg ) {}$/;"	f	class:Clara::CommandLine::OptBuilder
OptBuilder	tests/catch.hpp	/^            OptBuilder( OptBuilder& other ) : ArgBuilder( other ) {}$/;"	f	class:Clara::CommandLine::OptBuilder
OptBuilder	tests/catch.hpp	/^        class OptBuilder : public ArgBuilder {$/;"	c	class:Clara::CommandLine
Option	tests/catch.hpp	/^  Option() : nullableValue(CATCH_NULL) {}$/;"	f	class:Catch::Option
Option	tests/catch.hpp	/^  Option(Option const &_other)$/;"	f	class:Catch::Option
Option	tests/catch.hpp	/^  Option(T const &_value)$/;"	f	class:Catch::Option
Option	tests/catch.hpp	/^class Option {$/;"	c	namespace:Catch
OptionArgProperties	tests/catch.hpp	/^    struct OptionArgProperties {$/;"	s	namespace:Clara
OrNot	tests/catch.hpp	/^    struct ShowDurations { enum OrNot {$/;"	g	struct:Catch::ShowDurations
OriginalExpression	tests/catch.hpp	/^            OriginalExpression = Cyan,$/;"	e	enum:Catch::Colour::Code
OutputDebugWriter	tests/catch.hpp	/^    struct OutputDebugWriter {$/;"	s	namespace:Catch
Parser	tests/catch.hpp	/^        Parser() : mode( None ), from( 0 ), inQuotes( false ){}$/;"	f	class:Clara::Parser
Parser	tests/catch.hpp	/^    class Parser {$/;"	c	namespace:Clara
Pattern	tests/catch.hpp	/^        struct Pattern : SharedImpl<> {$/;"	s	class:Catch::TestSpec
Positional	tests/catch.hpp	/^            enum Type { Positional, ShortOpt, LongOpt };$/;"	e	enum:Clara::Parser::Token::Type
Positional	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	e	enum:Clara::Parser::Mode
PositionalArgProperties	tests/catch.hpp	/^        PositionalArgProperties() : position( -1 ) {}$/;"	f	struct:Clara::PositionalArgProperties
PositionalArgProperties	tests/catch.hpp	/^    struct PositionalArgProperties {$/;"	s	namespace:Clara
PosixColourImpl	tests/catch.hpp	/^    class PosixColourImpl : public IColourImpl {$/;"	c	namespace:Catch::__anond33fe2000610
Ptr	tests/catch.hpp	/^  Ptr() : m_p(CATCH_NULL) {}$/;"	f	class:Catch::Ptr
Ptr	tests/catch.hpp	/^  Ptr(Ptr const &other) : m_p(other.m_p) {$/;"	f	class:Catch::Ptr
Ptr	tests/catch.hpp	/^  Ptr(T *p) : m_p(p) {$/;"	f	class:Catch::Ptr
Ptr	tests/catch.hpp	/^class Ptr {$/;"	c	namespace:Catch
Quiet	tests/catch.hpp	/^        Quiet,$/;"	e	enum:Catch::Verbosity::Level
QuotedName	tests/catch.hpp	/^        enum Mode{ None, Name, QuotedName, Tag };$/;"	e	enum:Catch::TestSpecParser::Mode
RANDOM	file.h	/^    RANDOM = POSIX_FADV_RANDOM,$/;"	e	enum:File::ACCESS_ADVICE
READ_STATUS	file.h	/^  enum class READ_STATUS {$/;"	g	class:File
REGISTER_LEGACY_REPORTER	tests/catch.hpp	/^#define REGISTER_LEGACY_REPORTER(/;"	d
REGISTER_REPORTER	tests/catch.hpp	/^#define REGISTER_REPORTER(/;"	d
REGISTER_TEST_CASE	tests/catch.hpp	/^    #define REGISTER_TEST_CASE(/;"	d
REGISTER_TEST_CASE	tests/catch.hpp	/^#define REGISTER_TEST_CASE(/;"	d
REQUIRE	tests/catch.hpp	/^#define REQUIRE(/;"	d
REQUIRE_FALSE	tests/catch.hpp	/^#define REQUIRE_FALSE(/;"	d
REQUIRE_NOTHROW	tests/catch.hpp	/^#define REQUIRE_NOTHROW(/;"	d
REQUIRE_THAT	tests/catch.hpp	/^#define REQUIRE_THAT(/;"	d
REQUIRE_THROWS	tests/catch.hpp	/^#define REQUIRE_THROWS(/;"	d
REQUIRE_THROWS_AS	tests/catch.hpp	/^#define REQUIRE_THROWS_AS(/;"	d
REQUIRE_THROWS_WITH	tests/catch.hpp	/^#define REQUIRE_THROWS_WITH(/;"	d
RICANONTHERUN_FILE_H	file.h	/^#define  RICANONTHERUN_FILE_H$/;"	d
RandomNumberGenerator	tests/catch.hpp	/^    struct RandomNumberGenerator {$/;"	s	namespace:Catch
Read	file.cpp	/^File::READ_STATUS File::Read(ssize_t bytes) {$/;"	f	class:File	typeref:typename:File::READ_STATUS
ReadAll	file.cpp	/^File::READ_STATUS File::ReadAll() {$/;"	f	class:File	typeref:typename:File::READ_STATUS
ReadIntoBuffer	file.cpp	/^inline File::READ_STATUS File::ReadIntoBuffer(void * buffer, size_t bytes_to_read, ssize_t * byt/;"	f	class:File	typeref:typename:File::READ_STATUS
ReconstructedExpression	tests/catch.hpp	/^            ReconstructedExpression = Yellow,$/;"	e	enum:Catch::Colour::Code
Red	tests/catch.hpp	/^            Red,$/;"	e	enum:Catch::Colour::Code
RegistrarForTagAliases	tests/catch.hpp	/^    RegistrarForTagAliases::RegistrarForTagAliases( char const* alias, char const* tag, SourceLi/;"	f	class:Catch::RegistrarForTagAliases
RegistrarForTagAliases	tests/catch.hpp	/^struct RegistrarForTagAliases {$/;"	s	namespace:Catch
RegistryHub	tests/catch.hpp	/^            RegistryHub() {$/;"	f	class:Catch::__anond33fe2000210::RegistryHub
RegistryHub	tests/catch.hpp	/^        class RegistryHub : public IRegistryHub, public IMutableRegistryHub {$/;"	c	namespace:Catch::__anond33fe2000210
RemoveConstRef	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef<T const&>{ typedef T type; };$/;"	s	namespace:Clara::Detail
RemoveConstRef	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef<T const>{ typedef T type; };$/;"	s	namespace:Clara::Detail
RemoveConstRef	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef<T&>{ typedef T type; };$/;"	s	namespace:Clara::Detail
RemoveConstRef	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef{ typedef T type; };$/;"	s	namespace:Clara::Detail
ReporterConfig	tests/catch.hpp	/^        ReporterConfig( Ptr<IConfig const> const& _fullConfig, std::ostream& _stream )$/;"	f	struct:Catch::ReporterConfig
ReporterConfig	tests/catch.hpp	/^        explicit ReporterConfig( Ptr<IConfig const> const& _fullConfig )$/;"	f	struct:Catch::ReporterConfig
ReporterConfig	tests/catch.hpp	/^    struct ReporterConfig {$/;"	s	namespace:Catch
ReporterFactory	tests/catch.hpp	/^        class ReporterFactory : public IReporterFactory {$/;"	c	class:Catch::LegacyReporterRegistrar
ReporterFactory	tests/catch.hpp	/^        class ReporterFactory : public SharedImpl<IReporterFactory> {$/;"	c	class:Catch::ReporterRegistrar
ReporterPreferences	tests/catch.hpp	/^        ReporterPreferences()$/;"	f	struct:Catch::ReporterPreferences
ReporterPreferences	tests/catch.hpp	/^    struct ReporterPreferences {$/;"	s	namespace:Catch
ReporterRegistrar	tests/catch.hpp	/^        ReporterRegistrar( std::string const& name ) {$/;"	f	class:Catch::ReporterRegistrar
ReporterRegistrar	tests/catch.hpp	/^    class ReporterRegistrar {$/;"	c	namespace:Catch
ReporterRegistry	tests/catch.hpp	/^    class ReporterRegistry : public IReporterRegistry {$/;"	c	namespace:Catch
Reporters	tests/catch.hpp	/^    typedef std::vector<Ptr<IStreamingReporter> > Reporters;$/;"	t	class:Catch::MultipleReporters	typeref:typename:std::vector<Ptr<IStreamingReporter>>
ResultBuilder	tests/catch.hpp	/^    ResultBuilder::ResultBuilder(   char const* macroName,$/;"	f	class:Catch::ResultBuilder
ResultBuilder	tests/catch.hpp	/^class ResultBuilder {$/;"	c	namespace:Catch
ResultDisposition	tests/catch.hpp	/^struct ResultDisposition {$/;"	s	namespace:Catch
ResultError	tests/catch.hpp	/^            ResultError = BrightRed,$/;"	e	enum:Catch::Colour::Code
ResultExpectedFailure	tests/catch.hpp	/^            ResultExpectedFailure = Warning,$/;"	e	enum:Catch::Colour::Code
ResultSuccess	tests/catch.hpp	/^            ResultSuccess = BrightGreen,$/;"	e	enum:Catch::Colour::Code
ResultWas	tests/catch.hpp	/^struct ResultWas {$/;"	s	namespace:Catch
RunContext	tests/catch.hpp	/^        explicit RunContext( Ptr<IConfig const> const& _config, Ptr<IStreamingReporter> const& r/;"	f	class:Catch::RunContext
RunContext	tests/catch.hpp	/^    class RunContext : public IResultCapture, public IRunner {$/;"	c	namespace:Catch
RunState	tests/catch.hpp	/^        enum RunState {$/;"	g	class:Catch::TestCaseTracking::TrackerContext
RunTests	tests/catch.hpp	/^    struct RunTests { enum InWhatOrder {$/;"	s	namespace:Catch
SCENARIO	tests/catch.hpp	/^                                                                                                /;"	d
SCENARIO	tests/catch.hpp	/^#define SCENARIO(/;"	d
SCENARIO_METHOD	tests/catch.hpp	/^#define SCENARIO_METHOD(/;"	d
SCOPED_CAPTURE	tests/catch.hpp	/^#define SCOPED_CAPTURE(/;"	d
SCOPED_INFO	tests/catch.hpp	/^#define SCOPED_INFO(/;"	d
SECTION	tests/catch.hpp	/^    #define SECTION(/;"	d
SECTION	tests/catch.hpp	/^#define SECTION(/;"	d
SEQUENTIAL	file.h	/^    SEQUENTIAL = POSIX_FADV_SEQUENTIAL,$/;"	e	enum:File::ACCESS_ADVICE
STATUS	file.h	/^  enum class STATUS {$/;"	g	class:File
STITCH_CLARA_CLOSE_NAMESPACE	tests/catch.hpp	/^#define STITCH_CLARA_CLOSE_NAMESPACE /;"	d
STITCH_CLARA_CLOSE_NAMESPACE	tests/catch.hpp	/^#define STITCH_CLARA_CLOSE_NAMESPACE$/;"	d
STITCH_CLARA_OPEN_NAMESPACE	tests/catch.hpp	/^#define STITCH_CLARA_OPEN_NAMESPACE /;"	d
STITCH_CLARA_OPEN_NAMESPACE	tests/catch.hpp	/^#define STITCH_CLARA_OPEN_NAMESPACE$/;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	tests/catch.hpp	/^#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE /;"	d
STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE	tests/catch.hpp	/^namespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {$/;"	n
SUCCEED	tests/catch.hpp	/^    #define SUCCEED(/;"	d
SUCCEED	tests/catch.hpp	/^#define SUCCEED(/;"	d
SafeBool	tests/catch.hpp	/^class SafeBool {$/;"	c	namespace:Catch
ScopedElement	tests/catch.hpp	/^            ScopedElement( ScopedElement const& other )$/;"	f	class:Catch::XmlWriter::ScopedElement
ScopedElement	tests/catch.hpp	/^            ScopedElement( XmlWriter* writer )$/;"	f	class:Catch::XmlWriter::ScopedElement
ScopedElement	tests/catch.hpp	/^        class ScopedElement {$/;"	c	class:Catch::XmlWriter
ScopedMessage	tests/catch.hpp	/^    ScopedMessage::ScopedMessage( MessageBuilder const& builder )$/;"	f	class:Catch::ScopedMessage
ScopedMessage	tests/catch.hpp	/^    ScopedMessage::ScopedMessage( ScopedMessage const& other )$/;"	f	class:Catch::ScopedMessage
ScopedMessage	tests/catch.hpp	/^class ScopedMessage {$/;"	c	namespace:Catch
SecondaryText	tests/catch.hpp	/^            SecondaryText = LightGrey,$/;"	e	enum:Catch::Colour::Code
Section	tests/catch.hpp	/^    Section::Section( SectionInfo const& info )$/;"	f	class:Catch::Section
Section	tests/catch.hpp	/^class Section : NonCopyable {$/;"	c	namespace:Catch
SectionEndInfo	tests/catch.hpp	/^  SectionEndInfo(SectionInfo const &_sectionInfo, Counts const &_prevAssertions, double _duratio/;"	f	struct:Catch::SectionEndInfo
SectionEndInfo	tests/catch.hpp	/^struct SectionEndInfo {$/;"	s	namespace:Catch
SectionInfo	tests/catch.hpp	/^    SectionInfo::SectionInfo$/;"	f	class:Catch::SectionInfo
SectionInfo	tests/catch.hpp	/^struct SectionInfo {$/;"	s	namespace:Catch
SectionNode	tests/catch.hpp	/^            explicit SectionNode( SectionStats const& _stats ) : stats( _stats ) {}$/;"	f	struct:Catch::CumulativeReporterBase::SectionNode
SectionNode	tests/catch.hpp	/^        struct SectionNode : SharedImpl<> {$/;"	s	struct:Catch::CumulativeReporterBase
SectionStats	tests/catch.hpp	/^        SectionStats(   SectionInfo const& _sectionInfo,$/;"	f	struct:Catch::SectionStats
SectionStats	tests/catch.hpp	/^    struct SectionStats {$/;"	s	namespace:Catch
SectionTracker	tests/catch.hpp	/^        SectionTracker( std::string const& name, TrackerContext& ctx, ITracker* parent )$/;"	f	class:Catch::TestCaseTracking::SectionTracker
SectionTracker	tests/catch.hpp	/^    class SectionTracker : public TrackerBase {$/;"	c	namespace:Catch::TestCaseTracking
Session	tests/catch.hpp	/^        Session()$/;"	f	class:Catch::Session
Session	tests/catch.hpp	/^    class Session : NonCopyable {$/;"	c	namespace:Catch
SetOpenMode	file.cpp	/^File& File::SetOpenMode(int mode) {$/;"	f	class:File	typeref:typename:File &
SetReadAdvice	file.cpp	/^File& File::SetReadAdvice(ACCESS_ADVICE advice) {$/;"	f	class:File	typeref:typename:File &
SharedImpl	tests/catch.hpp	/^  SharedImpl() : m_rc(0) {}$/;"	f	struct:Catch::SharedImpl
SharedImpl	tests/catch.hpp	/^struct SharedImpl : T {$/;"	s	namespace:Catch
ShortOpt	tests/catch.hpp	/^            enum Type { Positional, ShortOpt, LongOpt };$/;"	e	enum:Clara::Parser::Token::Type
ShortOpt	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	e	enum:Clara::Parser::Mode
ShouldFail	tests/catch.hpp	/^    ShouldFail = 1 << 2,$/;"	e	enum:Catch::TestCaseInfo::SpecialProperties
ShowDurations	tests/catch.hpp	/^    struct ShowDurations { enum OrNot {$/;"	s	namespace:Catch
SignalDefs	tests/catch.hpp	/^    struct SignalDefs { int id; const char* name; };$/;"	s	namespace:Catch
SlashOpt	tests/catch.hpp	/^        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };$/;"	e	enum:Clara::Parser::Mode
SourceLineInfo	tests/catch.hpp	/^    SourceLineInfo::SourceLineInfo( SourceLineInfo const& other )$/;"	f	class:Catch::SourceLineInfo
SourceLineInfo	tests/catch.hpp	/^    SourceLineInfo::SourceLineInfo( char const* _file, std::size_t _line )$/;"	f	class:Catch::SourceLineInfo
SourceLineInfo	tests/catch.hpp	/^    SourceLineInfo::SourceLineInfo() : line( 0 ){}$/;"	f	class:Catch::SourceLineInfo
SourceLineInfo	tests/catch.hpp	/^struct SourceLineInfo {$/;"	s	namespace:Catch
SpecialProperties	tests/catch.hpp	/^  enum SpecialProperties {$/;"	g	struct:Catch::TestCaseInfo
StartsWith	tests/catch.hpp	/^                StartsWith( NSString* substr ) : StringHolder( substr ){}$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::StartsWith
StartsWith	tests/catch.hpp	/^            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr );/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::NSStringMatchers::StartsWith
StartsWith	tests/catch.hpp	/^            struct StartsWith : StringHolder<StartsWith> {$/;"	s	namespace:Catch::Matchers::Impl::NSStringMatchers
StartsWith	tests/catch.hpp	/^  StartsWith(StartsWith const &other) : m_data(other.m_data) {}$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith
StartsWith	tests/catch.hpp	/^  StartsWith(std::string const &substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Y/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith
StartsWith	tests/catch.hpp	/^inline Impl::StdString::StartsWith StartsWith(const char *substr) {$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::StartsWith
StartsWith	tests/catch.hpp	/^inline Impl::StdString::StartsWith StartsWith(std::string const &substr) {$/;"	f	namespace:Catch::Matchers	typeref:typename:Impl::StdString::StartsWith
StartsWith	tests/catch.hpp	/^struct StartsWith : MatcherImpl<StartsWith, std::string> {$/;"	s	namespace:Catch::Matchers::Impl::StdString
StdString	tests/catch.hpp	/^namespace StdString {$/;"	n	namespace:Catch::Matchers::Impl
StreamBufBase	tests/catch.hpp	/^    class StreamBufBase : public std::streambuf {$/;"	c	namespace:Catch
StreamBufImpl	tests/catch.hpp	/^        StreamBufImpl() {$/;"	f	class:Catch::StreamBufImpl
StreamBufImpl	tests/catch.hpp	/^    class StreamBufImpl : public StreamBufBase {$/;"	c	namespace:Catch
StreamEndStop	tests/catch.hpp	/^struct StreamEndStop {$/;"	s	namespace:Catch
StreamRedirect	tests/catch.hpp	/^        StreamRedirect( std::ostream& stream, std::string& targetString )$/;"	f	class:Catch::StreamRedirect
StreamRedirect	tests/catch.hpp	/^    class StreamRedirect {$/;"	c	namespace:Catch
StreamingReporterBase	tests/catch.hpp	/^        StreamingReporterBase( ReporterConfig const& _config )$/;"	f	struct:Catch::StreamingReporterBase
StreamingReporterBase	tests/catch.hpp	/^    struct StreamingReporterBase : SharedImpl<IStreamingReporter> {$/;"	s	namespace:Catch
StringHolder	tests/catch.hpp	/^                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::StringHolder
StringHolder	tests/catch.hpp	/^                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::StringHolder
StringHolder	tests/catch.hpp	/^                StringHolder() {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::StringHolder
StringHolder	tests/catch.hpp	/^            struct StringHolder : MatcherImpl<MatcherT, NSString*>{$/;"	s	namespace:Catch::Matchers::Impl::NSStringMatchers
StringMaker	tests/catch.hpp	/^struct StringMaker :$/;"	s	namespace:Catch
StringMaker	tests/catch.hpp	/^struct StringMaker<R C::*> {$/;"	s	namespace:Catch
StringMaker	tests/catch.hpp	/^struct StringMaker<T *> {$/;"	s	namespace:Catch
StringMaker	tests/catch.hpp	/^struct StringMaker<std::tuple<Types...>> {$/;"	s	namespace:Catch
StringMakerBase	tests/catch.hpp	/^struct StringMakerBase {$/;"	s	namespace:Catch::Detail
StringMakerBase	tests/catch.hpp	/^struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
Success	tests/catch.hpp	/^            Success = Green,$/;"	e	enum:Catch::Colour::Code
SummaryColumn	tests/catch.hpp	/^            SummaryColumn( std::string const& _label, Colour::Code _colour )$/;"	f	struct:Catch::ConsoleReporter::SummaryColumn
SummaryColumn	tests/catch.hpp	/^        struct SummaryColumn {$/;"	s	struct:Catch::ConsoleReporter
SuppressFail	tests/catch.hpp	/^    SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
TBC_TEXT_FORMAT_CONSOLE_WIDTH	tests/catch.hpp	/^#define TBC_TEXT_FORMAT_CONSOLE_WIDTH /;"	d
TBC_TEXT_FORMAT_H_INCLUDED	tests/catch.hpp	/^#define TBC_TEXT_FORMAT_H_INCLUDED$/;"	d
TESTS_HEADER_H	tests/test_header.h	/^#define TESTS_HEADER_H$/;"	d
TEST_CASE	tests/catch.hpp	/^                                                                                                /;"	d
TEST_CASE	tests/catch.hpp	/^#define TEST_CASE(/;"	d
TEST_CASE_METHOD	tests/catch.hpp	/^    #define TEST_CASE_METHOD(/;"	d
TEST_CASE_METHOD	tests/catch.hpp	/^#define TEST_CASE_METHOD(/;"	d
THEN	tests/catch.hpp	/^#define THEN(/;"	d
TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CLARA_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMMON_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_SECTION_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_STREAM_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEXT_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TIMER_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_VERSION_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED$/;"	d
TWOBLUECUBES_CLARA_H_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_CLARA_H_INCLUDED$/;"	d
TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED	tests/catch.hpp	/^#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED$/;"	d
TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED	tests/catch.hpp	/^#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED$/;"	d
TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED	tests/catch.hpp	/^#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED$/;"	d
Tag	tests/catch.hpp	/^        enum Mode{ None, Name, QuotedName, Tag };$/;"	e	enum:Catch::TestSpecParser::Mode
TagAlias	tests/catch.hpp	/^  TagAlias(std::string _tag, SourceLineInfo _lineInfo) : tag(_tag), lineInfo(_lineInfo) {}$/;"	f	struct:Catch::TagAlias
TagAlias	tests/catch.hpp	/^struct TagAlias {$/;"	s	namespace:Catch
TagAliasRegistry	tests/catch.hpp	/^    class TagAliasRegistry : public ITagAliasRegistry {$/;"	c	namespace:Catch
TagInfo	tests/catch.hpp	/^        TagInfo() : count ( 0 ) {}$/;"	f	struct:Catch::TagInfo
TagInfo	tests/catch.hpp	/^    struct TagInfo {$/;"	s	namespace:Catch
TagPattern	tests/catch.hpp	/^            TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}$/;"	f	class:Catch::TestSpec::TagPattern
TagPattern	tests/catch.hpp	/^        class TagPattern : public Pattern {$/;"	c	class:Catch::TestSpec
Tbc	tests/catch.hpp	/^namespace Tbc {$/;"	n	namespace:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
Tbc	tests/catch.hpp	/^namespace Tbc {$/;"	n	namespace:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
TestCase	tests/catch.hpp	/^    TestCase::TestCase( ITestCase* testCase, TestCaseInfo const& info ) : TestCaseInfo( info ), /;"	f	class:Catch::TestCase
TestCase	tests/catch.hpp	/^    TestCase::TestCase( TestCase const& other )$/;"	f	class:Catch::TestCase
TestCase	tests/catch.hpp	/^class TestCase : public TestCaseInfo {$/;"	c	namespace:Catch
TestCaseInfo	tests/catch.hpp	/^    TestCaseInfo::TestCaseInfo( TestCaseInfo const& other )$/;"	f	class:Catch::TestCaseInfo
TestCaseInfo	tests/catch.hpp	/^    TestCaseInfo::TestCaseInfo( std::string const& _name,$/;"	f	class:Catch::TestCaseInfo
TestCaseInfo	tests/catch.hpp	/^struct TestCaseInfo {$/;"	s	namespace:Catch
TestCaseNode	tests/catch.hpp	/^        typedef Node<TestCaseStats, SectionNode> TestCaseNode;$/;"	t	struct:Catch::CumulativeReporterBase	typeref:typename:Node<TestCaseStats,SectionNode>
TestCaseStats	tests/catch.hpp	/^        TestCaseStats(  TestCaseInfo const& _testInfo,$/;"	f	struct:Catch::TestCaseStats
TestCaseStats	tests/catch.hpp	/^    struct TestCaseStats {$/;"	s	namespace:Catch
TestCaseTracking	tests/catch.hpp	/^    namespace TestCaseTracking {$/;"	n	namespace:Catch
TestCaseTracking	tests/catch.hpp	/^namespace TestCaseTracking {$/;"	n	namespace:Catch
TestEventListenerBase	tests/catch.hpp	/^        TestEventListenerBase( ReporterConfig const& _config )$/;"	f	struct:Catch::TestEventListenerBase
TestEventListenerBase	tests/catch.hpp	/^    struct TestEventListenerBase : StreamingReporterBase {$/;"	s	namespace:Catch
TestFailureException	tests/catch.hpp	/^struct TestFailureException {};$/;"	s	namespace:Catch
TestFunction	tests/catch.hpp	/^typedef void(*TestFunction)();$/;"	t	namespace:Catch	typeref:typename:void (*)()
TestGroupNode	tests/catch.hpp	/^        typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;$/;"	t	struct:Catch::CumulativeReporterBase	typeref:typename:Node<TestGroupStats,TestCaseNode>
TestGroupStats	tests/catch.hpp	/^        TestGroupStats( GroupInfo const& _groupInfo )$/;"	f	struct:Catch::TestGroupStats
TestGroupStats	tests/catch.hpp	/^        TestGroupStats( GroupInfo const& _groupInfo,$/;"	f	struct:Catch::TestGroupStats
TestGroupStats	tests/catch.hpp	/^    struct TestGroupStats {$/;"	s	namespace:Catch
TestRegistry	tests/catch.hpp	/^        TestRegistry()$/;"	f	class:Catch::TestRegistry
TestRegistry	tests/catch.hpp	/^    class TestRegistry : public ITestCaseRegistry {$/;"	c	namespace:Catch
TestRunInfo	tests/catch.hpp	/^        TestRunInfo( std::string const& _name ) : name( _name ) {}$/;"	f	struct:Catch::TestRunInfo
TestRunInfo	tests/catch.hpp	/^    struct TestRunInfo {$/;"	s	namespace:Catch
TestRunNode	tests/catch.hpp	/^        typedef Node<TestRunStats, TestGroupNode> TestRunNode;$/;"	t	struct:Catch::CumulativeReporterBase	typeref:typename:Node<TestRunStats,TestGroupNode>
TestRunStats	tests/catch.hpp	/^        TestRunStats(   TestRunInfo const& _runInfo,$/;"	f	struct:Catch::TestRunStats
TestRunStats	tests/catch.hpp	/^        TestRunStats( TestRunStats const& _other )$/;"	f	struct:Catch::TestRunStats
TestRunStats	tests/catch.hpp	/^    struct TestRunStats {$/;"	s	namespace:Catch
TestSpec	tests/catch.hpp	/^    class TestSpec {$/;"	c	namespace:Catch
TestSpecParser	tests/catch.hpp	/^        TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}$/;"	f	class:Catch::TestSpecParser
TestSpecParser	tests/catch.hpp	/^    class TestSpecParser {$/;"	c	namespace:Catch
Text	tests/catch.hpp	/^        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text
Text	tests/catch.hpp	/^        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text
Text	tests/catch.hpp	/^    class Text {$/;"	c	namespace:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc
Text	tests/catch.hpp	/^    class Text {$/;"	c	namespace:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc
TextAttributes	tests/catch.hpp	/^        TextAttributes()$/;"	f	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes
TextAttributes	tests/catch.hpp	/^        TextAttributes()$/;"	f	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes
TextAttributes	tests/catch.hpp	/^    struct TextAttributes {$/;"	s	namespace:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc
TextAttributes	tests/catch.hpp	/^    struct TextAttributes {$/;"	s	namespace:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc
ThrewException	tests/catch.hpp	/^    ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
Throws	tests/catch.hpp	/^    Throws = 1 << 4$/;"	e	enum:Catch::TestCaseInfo::SpecialProperties
Timer	tests/catch.hpp	/^  Timer() : m_ticks(0) {}$/;"	f	class:Catch::Timer
Timer	tests/catch.hpp	/^class Timer {$/;"	c	namespace:Catch
Token	tests/catch.hpp	/^            Token( Type _type, std::string const& _data ) : type( _type ), data( _data ) {}$/;"	f	struct:Clara::Parser::Token
Token	tests/catch.hpp	/^        struct Token {$/;"	s	class:Clara::Parser
Totals	tests/catch.hpp	/^struct Totals {$/;"	s	namespace:Catch
TrackerBase	tests/catch.hpp	/^        TrackerBase( std::string const& name, TrackerContext& ctx, ITracker* parent )$/;"	f	class:Catch::TestCaseTracking::TrackerBase
TrackerBase	tests/catch.hpp	/^    class TrackerBase : public ITracker {$/;"	c	namespace:Catch::TestCaseTracking
TrackerContext	tests/catch.hpp	/^        TrackerContext()$/;"	f	class:Catch::TestCaseTracking::TrackerContext
TrackerContext	tests/catch.hpp	/^    class TrackerContext {$/;"	c	namespace:Catch::TestCaseTracking
TrackerHasName	tests/catch.hpp	/^            TrackerHasName( std::string const& name ) : m_name( name ) {}$/;"	f	class:Catch::TestCaseTracking::TrackerBase::TrackerHasName
TrackerHasName	tests/catch.hpp	/^        class TrackerHasName {$/;"	c	class:Catch::TestCaseTracking::TrackerBase
TrueType	tests/catch.hpp	/^struct TrueType { char sizer[1]; };$/;"	s	namespace:Catch::Detail
TupleDetail	tests/catch.hpp	/^namespace TupleDetail {$/;"	n	namespace:Catch
Type	tests/catch.hpp	/^            enum Type { Positional, ShortOpt, LongOpt };$/;"	g	struct:Clara::Parser::Token
Unknown	tests/catch.hpp	/^    Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
UnpositionalTag	tests/catch.hpp	/^    struct UnpositionalTag {};$/;"	s	namespace:Clara
UseColour	tests/catch.hpp	/^    struct UseColour { enum YesOrNo {$/;"	s	namespace:Catch
ValuesGenerator	tests/catch.hpp	/^  ValuesGenerator() {}$/;"	f	class:Catch::ValuesGenerator
ValuesGenerator	tests/catch.hpp	/^class ValuesGenerator : public IGenerator<T> {$/;"	c	namespace:Catch
Verbosity	tests/catch.hpp	/^    struct Verbosity { enum Level {$/;"	s	namespace:Catch
Version	tests/catch.hpp	/^    Version::Version$/;"	f	class:Catch::Version
Version	tests/catch.hpp	/^    struct Version {$/;"	s	namespace:Catch
WARN	tests/catch.hpp	/^#define WARN(/;"	d
WHEN	tests/catch.hpp	/^#define WHEN(/;"	d
WILLNEED	file.h	/^    WILLNEED = POSIX_FADV_WILLNEED,$/;"	e	enum:File::ACCESS_ADVICE
WarnAbout	tests/catch.hpp	/^    struct WarnAbout { enum What {$/;"	s	namespace:Catch
Warning	tests/catch.hpp	/^            Warning = Yellow,$/;"	e	enum:Catch::Colour::Code
Warning	tests/catch.hpp	/^    Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
What	tests/catch.hpp	/^    struct WarnAbout { enum What {$/;"	g	struct:Catch::WarnAbout
White	tests/catch.hpp	/^            White,$/;"	e	enum:Catch::Colour::Code
WildcardAtBothEnds	tests/catch.hpp	/^            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd$/;"	e	enum:Catch::WildcardPattern::WildcardPosition
WildcardAtEnd	tests/catch.hpp	/^            WildcardAtEnd = 2,$/;"	e	enum:Catch::WildcardPattern::WildcardPosition
WildcardAtStart	tests/catch.hpp	/^            WildcardAtStart = 1,$/;"	e	enum:Catch::WildcardPattern::WildcardPosition
WildcardPattern	tests/catch.hpp	/^        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity )$/;"	f	class:Catch::WildcardPattern
WildcardPattern	tests/catch.hpp	/^    class WildcardPattern {$/;"	c	namespace:Catch
WildcardPosition	tests/catch.hpp	/^        enum WildcardPosition {$/;"	g	class:Catch::WildcardPattern
Win32ColourImpl	tests/catch.hpp	/^        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )$/;"	f	class:Catch::__anond33fe2000510::Win32ColourImpl
Win32ColourImpl	tests/catch.hpp	/^    class Win32ColourImpl : public IColourImpl {$/;"	c	namespace:Catch::__anond33fe2000510
Write	file.cpp	/^void File::Write(const char * buf, size_t len) {$/;"	f	class:File	typeref:typename:void
XmlEncode	tests/catch.hpp	/^        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes )$/;"	f	class:Catch::XmlEncode
XmlEncode	tests/catch.hpp	/^    class XmlEncode {$/;"	c	namespace:Catch
XmlReporter	tests/catch.hpp	/^        XmlReporter( ReporterConfig const& _config )$/;"	f	class:Catch::XmlReporter
XmlReporter	tests/catch.hpp	/^    class XmlReporter : public StreamingReporterBase {$/;"	c	namespace:Catch
XmlWriter	tests/catch.hpp	/^        XmlWriter( std::ostream& os )$/;"	f	class:Catch::XmlWriter
XmlWriter	tests/catch.hpp	/^        XmlWriter()$/;"	f	class:Catch::XmlWriter
XmlWriter	tests/catch.hpp	/^    class XmlWriter {$/;"	c	namespace:Catch
Yellow	tests/catch.hpp	/^            Yellow,$/;"	e	enum:Catch::Colour::Code
Yes	tests/catch.hpp	/^        Yes,$/;"	e	enum:Catch::UseColour::YesOrNo
Yes	tests/catch.hpp	/^    Yes,$/;"	e	enum:Catch::CaseSensitive::Choice
YesOrNo	tests/catch.hpp	/^    struct UseColour { enum YesOrNo {$/;"	g	struct:Catch::UseColour
_	tests/catch.hpp	/^                union _{$/;"	u	function:Catch::Detail::__anond33fe2000810::Endianness::which
_	tests/catch.hpp	/^    UnpositionalTag _;$/;"	v	namespace:Clara	typeref:typename:UnpositionalTag
__anond33fe2000103	tests/catch.hpp	/^  enum { value = sizeof(testStreamable(s << t)) == sizeof(TrueType) };$/;"	g	struct:Catch::Detail::IsStreamInsertable
__anond33fe2000210	tests/catch.hpp	/^    namespace {$/;"	n	namespace:Catch
__anond33fe2000310	tests/catch.hpp	/^    namespace {$/;"	n	namespace:Catch
__anond33fe2000410	tests/catch.hpp	/^    namespace {$/;"	n	namespace:Catch
__anond33fe2000510	tests/catch.hpp	/^namespace {$/;"	n	namespace:Catch
__anond33fe2000610	tests/catch.hpp	/^namespace {$/;"	n	namespace:Catch
__anond33fe2000710	tests/catch.hpp	/^    namespace {$/;"	n	namespace:Catch
__anond33fe2000810	tests/catch.hpp	/^    namespace {$/;"	n	namespace:Catch::Detail
abortAfter	tests/catch.hpp	/^        int abortAfter() const { return m_data.abortAfter; }$/;"	f	class:Catch::Config	typeref:typename:int
abortAfter	tests/catch.hpp	/^        int abortAfter;$/;"	m	struct:Catch::ConfigData	typeref:typename:int
abortAfterFirst	tests/catch.hpp	/^    inline void abortAfterFirst( ConfigData& config ) { config.abortAfter = 1; }$/;"	f	namespace:Catch	typeref:typename:void
abortAfterX	tests/catch.hpp	/^    inline void abortAfterX( ConfigData& config, int x ) {$/;"	f	namespace:Catch	typeref:typename:void
aborting	tests/catch.hpp	/^        bool aborting() const {$/;"	f	class:Catch::RunContext	typeref:typename:bool
aborting	tests/catch.hpp	/^        bool aborting;$/;"	m	struct:Catch::TestCaseStats	typeref:typename:bool
aborting	tests/catch.hpp	/^        bool aborting;$/;"	m	struct:Catch::TestGroupStats	typeref:typename:bool
aborting	tests/catch.hpp	/^        bool aborting;$/;"	m	struct:Catch::TestRunStats	typeref:typename:bool
add	tests/catch.hpp	/^        void add( std::string const& spelling ) {$/;"	f	struct:Catch::TagInfo	typeref:typename:void
add	tests/catch.hpp	/^    void TagAliasRegistry::add( char const* alias, char const* tag, SourceLineInfo const& lineIn/;"	f	class:Catch::TagAliasRegistry	typeref:typename:void
add	tests/catch.hpp	/^    void add( Ptr<IStreamingReporter> const& reporter ) {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
add	tests/catch.hpp	/^  AllOf &add(Matcher<ExpressionT> const &matcher) {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	typeref:typename:AllOf &
add	tests/catch.hpp	/^  AnyOf &add(Matcher<ExpressionT> const &matcher) {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	typeref:typename:AnyOf &
add	tests/catch.hpp	/^  void add(T value) {$/;"	f	class:Catch::ValuesGenerator	typeref:typename:void
add	tests/catch.hpp	/^  void add(const IGenerator<T> *generator) {$/;"	f	class:Catch::CompositeGenerator	typeref:typename:void
addFilter	tests/catch.hpp	/^        void addFilter() {$/;"	f	class:Catch::TestSpecParser	typeref:typename:void
addListeners	tests/catch.hpp	/^    Ptr<IStreamingReporter> addListeners( Ptr<IConfig const> const& config, Ptr<IStreamingReport/;"	f	namespace:Catch	typeref:typename:Ptr<IStreamingReporter>
addOptName	tests/catch.hpp	/^        friend void addOptName( Arg& arg, std::string const& optName )$/;"	f	class:Clara::CommandLine	typeref:typename:void
addPattern	tests/catch.hpp	/^        void addPattern() {$/;"	f	class:Catch::TestSpecParser	typeref:typename:void
addRef	tests/catch.hpp	/^  virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl	typeref:typename:void
addReporter	tests/catch.hpp	/^Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStrea/;"	f	namespace:Catch	typeref:typename:Ptr<IStreamingReporter>
addReporterName	tests/catch.hpp	/^    inline void addReporterName( ConfigData& config, std::string const& _reporterName ) { config/;"	f	namespace:Catch	typeref:typename:void
addRow	tests/catch.hpp	/^            SummaryColumn addRow( std::size_t count ) {$/;"	f	struct:Catch::ConsoleReporter::SummaryColumn	typeref:typename:SummaryColumn
addTestOrTags	tests/catch.hpp	/^    inline void addTestOrTags( ConfigData& config, std::string const& _testSpec ) { config.tests/;"	f	namespace:Catch	typeref:typename:void
addWarning	tests/catch.hpp	/^    inline void addWarning( ConfigData& config, std::string const& _warning ) {$/;"	f	namespace:Catch	typeref:typename:void
adjustCase	tests/catch.hpp	/^        std::string adjustCase( std::string const& str ) const {$/;"	f	class:Catch::WildcardPattern	typeref:typename:std::string
adjustString	tests/catch.hpp	/^  std::string adjustString(std::string const &str) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	typeref:typename:std::string
advanceGeneratorsForCurrentTest	tests/catch.hpp	/^        virtual bool advanceGeneratorsForCurrentTest() {$/;"	f	class:Catch::Context	typeref:typename:bool
advice	file.h	/^    ACCESS_ADVICE advice;$/;"	m	class:File	typeref:typename:ACCESS_ADVICE
all	tests/catch.hpp	/^        std::string all() const {$/;"	f	struct:Catch::TagInfo	typeref:typename:std::string
allOk	tests/catch.hpp	/^  bool allOk() const {$/;"	f	struct:Catch::Counts	typeref:typename:bool
allPassed	tests/catch.hpp	/^  bool allPassed() const {$/;"	f	struct:Catch::Counts	typeref:typename:bool
allowThrows	tests/catch.hpp	/^        virtual bool allowThrows() const        { return !m_data.noThrow; }$/;"	f	class:Catch::Config	typeref:typename:bool
allowThrows	tests/catch.hpp	/^    bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrow/;"	f	class:Catch::ResultBuilder	typeref:typename:bool
alreadyInstantiated	tests/catch.hpp	/^        static bool alreadyInstantiated;$/;"	m	class:Catch::Session	typeref:typename:bool
alreadyInstantiated	tests/catch.hpp	/^    bool Session::alreadyInstantiated = false;$/;"	m	class:Catch::Session	typeref:typename:bool
alwaysFalse	tests/catch.hpp	/^inline bool alwaysFalse() { return false; }$/;"	f	namespace:Catch	typeref:typename:bool
alwaysTrue	tests/catch.hpp	/^inline bool alwaysTrue() { return true; }$/;"	f	namespace:Catch	typeref:typename:bool
applyCommandLine	tests/catch.hpp	/^        int applyCommandLine( int argc, char const* const* const argv, OnUnusedOptions::DoWhat u/;"	f	class:Catch::Session	typeref:typename:int
applyEvaluator	tests/catch.hpp	/^bool applyEvaluator(T1 const &lhs, T2 const &rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
applyFilenamesAsTags	tests/catch.hpp	/^    void applyFilenamesAsTags( IConfig const& config ) {$/;"	f	namespace:Catch	typeref:typename:void
arcSafeRelease	tests/catch.hpp	/^inline void arcSafeRelease( NSObject* ){}$/;"	f	typeref:typename:void
arcSafeRelease	tests/catch.hpp	/^inline void arcSafeRelease( NSObject* obj ) {$/;"	f	typeref:typename:void
argSynopsis	tests/catch.hpp	/^        std::string argSynopsis() const {$/;"	f	class:Clara::CommandLine	typeref:typename:std::string
argSynopsis	tests/catch.hpp	/^        void argSynopsis( std::ostream& os ) const {$/;"	f	class:Clara::CommandLine	typeref:typename:void
argsToVector	tests/catch.hpp	/^    inline std::vector<std::string> argsToVector( int argc, char const* const* const argv ) {$/;"	f	namespace:Clara	typeref:typename:std::vector<std::string>
asChar	tests/catch.hpp	/^                    char asChar[sizeof (int)];$/;"	m	union:Catch::Detail::__anond33fe2000810::Endianness::which::_	typeref:typename:char[]
asInt	tests/catch.hpp	/^                    int asInt;$/;"	m	union:Catch::Detail::__anond33fe2000810::Endianness::which::_	typeref:typename:int
assertionEnded	tests/catch.hpp	/^        virtual bool assertionEnded( AssertionStats const& ) CATCH_OVERRIDE {$/;"	f	struct:Catch::TestEventListenerBase	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^        virtual bool assertionEnded( AssertionStats const& _assertionStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^        virtual bool assertionEnded( AssertionStats const& _assertionStats ) {$/;"	f	struct:Catch::CompactReporter	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::JunitReporter	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^        virtual void assertionEnded( AssertionResult const& result ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
assertionEnded	tests/catch.hpp	/^    bool LegacyReporterAdapter::assertionEnded( AssertionStats const& assertionStats ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:bool
assertionEnded	tests/catch.hpp	/^    virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:bool
assertionResult	tests/catch.hpp	/^        AssertionResult assertionResult;$/;"	m	struct:Catch::AssertionStats	typeref:typename:AssertionResult
assertionStarting	tests/catch.hpp	/^        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE { }$/;"	f	class:Catch::XmlReporter	typeref:typename:void
assertionStarting	tests/catch.hpp	/^        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
assertionStarting	tests/catch.hpp	/^        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
assertionStarting	tests/catch.hpp	/^        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}$/;"	f	struct:Catch::TestEventListenerBase	typeref:typename:void
assertionStarting	tests/catch.hpp	/^        virtual void assertionStarting( AssertionInfo const& ) {$/;"	f	struct:Catch::CompactReporter	typeref:typename:void
assertionStarting	tests/catch.hpp	/^    virtual void assertionStarting( AssertionInfo const& assertionInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
assertionStarting	tests/catch.hpp	/^    void LegacyReporterAdapter::assertionStarting( AssertionInfo const& ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
assertions	tests/catch.hpp	/^            Assertions assertions;$/;"	m	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:Assertions
assertions	tests/catch.hpp	/^        Counts assertions;$/;"	m	struct:Catch::SectionStats	typeref:typename:Counts
assertions	tests/catch.hpp	/^  Counts assertions;$/;"	m	struct:Catch::Totals	typeref:typename:Counts
attr	tests/catch.hpp	/^        TextAttributes attr;$/;"	m	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:TextAttributes
attr	tests/catch.hpp	/^        TextAttributes attr;$/;"	m	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:TextAttributes
begin	tests/catch.hpp	/^        const_iterator begin() const { return lines.begin(); }$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:const_iterator
begin	tests/catch.hpp	/^        const_iterator begin() const { return lines.begin(); }$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:const_iterator
between	tests/catch.hpp	/^CompositeGenerator<T> between(T from, T to) {$/;"	f	namespace:Catch::Generators	typeref:typename:CompositeGenerator<T>
bind	tests/catch.hpp	/^            void bind( M C::* field, std::string const& placeholder ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bind	tests/catch.hpp	/^            void bind( bool C::* field ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bind	tests/catch.hpp	/^            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bind	tests/catch.hpp	/^            void bind( void (* unaryFunction)( C& ) ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bind	tests/catch.hpp	/^            void bind( void (C::* nullaryMethod)() ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bind	tests/catch.hpp	/^            void bind( void (C::* unaryMethod)( M ), std::string const& placeholder ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bind	tests/catch.hpp	/^            void bind( void (C::* unaryMethod)( bool ) ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:void
bindProcessName	tests/catch.hpp	/^        void bindProcessName( M C::* field ) {$/;"	f	class:Clara::CommandLine	typeref:typename:void
bindProcessName	tests/catch.hpp	/^        void bindProcessName( void (C::*_unaryMethod)( M ) ) {$/;"	f	class:Clara::CommandLine	typeref:typename:void
bothOrAll	tests/catch.hpp	/^        std::string bothOrAll( std::size_t count ) const {$/;"	f	struct:Catch::CompactReporter	typeref:typename:std::string
boundField	tests/catch.hpp	/^        Detail::BoundArgFunction<ConfigT> boundField;$/;"	m	struct:Clara::CommonArgProperties	typeref:typename:Detail::BoundArgFunction<ConfigT>
branchName	tests/catch.hpp	/^        std::string const branchName;$/;"	m	struct:Catch::Version	typeref:typename:std::string const
buffer	file.h	/^    std::string buffer;$/;"	m	class:File	typeref:typename:std::string
buffer	tests/ReadTests.cpp	/^        std::stringstream buffer;$/;"	v	typeref:typename:std::stringstream
build	tests/catch.hpp	/^    AssertionResult ResultBuilder::build() const$/;"	f	class:Catch::ResultBuilder	typeref:typename:AssertionResult
buildNumber	tests/catch.hpp	/^        unsigned int const buildNumber;$/;"	m	struct:Catch::Version	typeref:typename:unsigned int const
captureExpectedException	tests/catch.hpp	/^    void ResultBuilder::captureExpectedException( Matchers::Impl::Matcher<std::string> const& ma/;"	f	class:Catch::ResultBuilder	typeref:typename:void
captureExpectedException	tests/catch.hpp	/^    void ResultBuilder::captureExpectedException( std::string const& expectedMessage ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
captureExpression	tests/catch.hpp	/^    void ResultBuilder::captureExpression() {$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
captureExpression	tests/catch.hpp	/^  ResultBuilder &captureExpression(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
captureResult	tests/catch.hpp	/^    void ResultBuilder::captureResult( ResultWas::OfType resultType ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
capturedExpression	tests/catch.hpp	/^  std::string capturedExpression;$/;"	m	struct:Catch::AssertionInfo	typeref:typename:std::string
capturedExpressionWithSecondArgument	tests/catch.hpp	/^    std::string capturedExpressionWithSecondArgument( std::string const& capturedExpression, std/;"	f	namespace:Catch	typeref:typename:std::string
cerr	tests/catch.hpp	/^    std::ostream& cerr() {$/;"	f	namespace:Catch	typeref:typename:std::ostream &
childSections	tests/catch.hpp	/^            ChildSections childSections;$/;"	m	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:ChildSections
childTracker	tests/catch.hpp	/^            if( ITracker* childTracker = currentTracker.findChild( name ) ) {$/;"	m	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:ITracker *
childTracker	tests/catch.hpp	/^            if( ITracker* childTracker = currentTracker.findChild( name ) ) {$/;"	m	class:Catch::TestCaseTracking::SectionTracker	typeref:typename:ITracker *
children	tests/catch.hpp	/^            ChildNodes children;$/;"	m	struct:Catch::CumulativeReporterBase::Node	typeref:typename:ChildNodes
className	tests/catch.hpp	/^  std::string className;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:std::string
cleanUp	tests/catch.hpp	/^    void cleanUp() {$/;"	f	namespace:Catch	typeref:typename:void
cleanUpContext	tests/catch.hpp	/^    void cleanUpContext() {$/;"	f	namespace:Catch	typeref:typename:void
cli	tests/catch.hpp	/^        Clara::CommandLine<ConfigData> const& cli() const {$/;"	f	class:Catch::Session	typeref:typename:Clara::CommandLine<ConfigData> const &
clone	tests/catch.hpp	/^            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }$/;"	f	struct:Clara::Detail::BoundBinaryFunction	typeref:typename:IArgFunction<C> *
clone	tests/catch.hpp	/^            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }$/;"	f	struct:Clara::Detail::BoundDataMember	typeref:typename:IArgFunction<C> *
clone	tests/catch.hpp	/^            virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod( *this ); }$/;"	f	struct:Clara::Detail::BoundNullaryMethod	typeref:typename:IArgFunction<C> *
clone	tests/catch.hpp	/^            virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction( *this ); }$/;"	f	struct:Clara::Detail::BoundUnaryFunction	typeref:typename:IArgFunction<C> *
clone	tests/catch.hpp	/^            virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod( *this ); }$/;"	f	struct:Clara::Detail::BoundUnaryMethod	typeref:typename:IArgFunction<C> *
clone	tests/catch.hpp	/^            virtual IArgFunction<C>* clone() const { return new NullBinder( *this ); }$/;"	f	struct:Clara::Detail::NullBinder	typeref:typename:IArgFunction<C> *
clone	tests/catch.hpp	/^  virtual Ptr<Matcher<ExpressionT> > clone() const {$/;"	f	struct:Catch::Matchers::Impl::MatcherImpl	typeref:typename:Ptr<Matcher<ExpressionT>>
close	tests/catch.hpp	/^        virtual void close() CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:void
close	tests/catch.hpp	/^        virtual void close() CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:void
colour	tests/catch.hpp	/^            Colour::Code colour;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:Colour::Code
colour	tests/catch.hpp	/^            Colour::Code colour;$/;"	m	struct:Catch::ConsoleReporter::SummaryColumn	typeref:typename:Colour::Code
commands	tests/catch.hpp	/^            std::string commands() const {$/;"	f	struct:Clara::CommandLine::Arg	typeref:typename:std::string
compare	tests/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(T *lhs, int rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(T *lhs, long rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(T1 const &lhs, T2 const &rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(int lhs, T *rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(int lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(int lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(int lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(long lhs, T *rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(long lhs, unsigned char rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(long lhs, unsigned int rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(long lhs, unsigned long rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(unsigned char lhs, int rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(unsigned char lhs, long rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(unsigned int lhs, int rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(unsigned int lhs, long rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(unsigned long lhs, int rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
compare	tests/catch.hpp	/^bool compare(unsigned long lhs, long rhs) {$/;"	f	namespace:Catch::Internal	typeref:typename:bool
completeCycle	tests/catch.hpp	/^        void completeCycle() {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:void
completedCycle	tests/catch.hpp	/^        bool completedCycle() const {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:bool
config	tests/catch.hpp	/^        Config& config() {$/;"	f	class:Catch::Session	typeref:typename:Config &
config	tests/catch.hpp	/^        Ptr<IConfig const> config() const {$/;"	f	class:Catch::RunContext	typeref:typename:Ptr<IConfig const>
configData	tests/catch.hpp	/^        ConfigData& configData() {$/;"	f	class:Catch::Session	typeref:typename:ConfigData &
consoleWidth	tests/catch.hpp	/^    const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;$/;"	v	namespace:Clara::Detail	typeref:typename:const unsigned int
consoleWidth	tests/catch.hpp	/^    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;$/;"	v	namespace:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc	typeref:typename:const unsigned int
consoleWidth	tests/catch.hpp	/^    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;$/;"	v	namespace:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc	typeref:typename:const unsigned int
const_iterator	tests/catch.hpp	/^        typedef std::vector<std::string>::const_iterator const_iterator;$/;"	t	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::vector<std::string>::const_iterator
const_iterator	tests/catch.hpp	/^        typedef std::vector<std::string>::const_iterator const_iterator;$/;"	t	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::vector<std::string>::const_iterator
contains	tests/catch.hpp	/^    bool contains( std::string const& s, std::string const& infix ) {$/;"	f	namespace:Catch	typeref:typename:bool
convert	tests/catch.hpp	/^        static std::string convert( T const& ) { return unprintableString; }$/;"	f	struct:Catch::Detail::EnumStringMaker	typeref:typename:std::string
convert	tests/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::EnumStringMaker	typeref:typename:std::string
convert	tests/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::StringMakerBase	typeref:typename:std::string
convert	tests/catch.hpp	/^    static std::string convert( const std::tuple<Types...>& tuple )$/;"	f	struct:Catch::StringMaker	typeref:typename:std::string
convert	tests/catch.hpp	/^  static std::string convert(R C::* p) {$/;"	f	struct:Catch::StringMaker	typeref:typename:std::string
convert	tests/catch.hpp	/^  static std::string convert(T const &_value) {$/;"	f	struct:Catch::Detail::StringMakerBase	typeref:typename:std::string
convert	tests/catch.hpp	/^  static std::string convert(U *p) {$/;"	f	struct:Catch::StringMaker	typeref:typename:std::string
convertInto	tests/catch.hpp	/^        inline void convertInto( std::string const& _source, bool& _dest ) {$/;"	f	namespace:Clara::Detail	typeref:typename:void
convertInto	tests/catch.hpp	/^        inline void convertInto( std::string const& _source, std::string& _dest ) {$/;"	f	namespace:Clara::Detail	typeref:typename:void
convertInto	tests/catch.hpp	/^        void convertInto( std::string const& _source, T& _dest ) {$/;"	f	namespace:Clara::Detail	typeref:typename:void
count	tests/catch.hpp	/^        std::size_t count;$/;"	m	struct:Catch::TagInfo	typeref:typename:std::size_t
cout	tests/catch.hpp	/^    std::ostream& cout() {$/;"	f	namespace:Catch	typeref:typename:std::ostream &
create	tests/catch.hpp	/^            virtual IStreamingReporter* create( ReporterConfig const& config ) const {$/;"	f	class:Catch::LegacyReporterRegistrar::ReporterFactory	typeref:typename:IStreamingReporter *
create	tests/catch.hpp	/^            virtual IStreamingReporter* create( ReporterConfig const& config ) const {$/;"	f	class:Catch::ListenerRegistrar::ListenerFactory	typeref:typename:IStreamingReporter *
create	tests/catch.hpp	/^            virtual IStreamingReporter* create( ReporterConfig const& config ) const {$/;"	f	class:Catch::ReporterRegistrar::ReporterFactory	typeref:typename:IStreamingReporter *
createGeneratorsForTest	tests/catch.hpp	/^    IGeneratorsForTest* createGeneratorsForTest()$/;"	f	namespace:Catch	typeref:typename:IGeneratorsForTest *
createReporter	tests/catch.hpp	/^    Ptr<IStreamingReporter> createReporter( std::string const& reporterName, Ptr<Config> const& /;"	f	namespace:Catch	typeref:typename:Ptr<IStreamingReporter>
currentContext	tests/catch.hpp	/^        Context* currentContext = CATCH_NULL;$/;"	v	namespace:Catch::__anond33fe2000310	typeref:typename:Context *
currentGroupInfo	tests/catch.hpp	/^        LazyStat<GroupInfo> currentGroupInfo;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:LazyStat<GroupInfo>
currentTestCaseInfo	tests/catch.hpp	/^        LazyStat<TestCaseInfo> currentTestCaseInfo;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:LazyStat<TestCaseInfo>
currentTestRunInfo	tests/catch.hpp	/^        LazyStat<TestRunInfo> currentTestRunInfo;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:LazyStat<TestRunInfo>
currentTracker	tests/catch.hpp	/^            ITracker& currentTracker = ctx.currentTracker();$/;"	m	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:ITracker &
currentTracker	tests/catch.hpp	/^            ITracker& currentTracker = ctx.currentTracker();$/;"	m	class:Catch::TestCaseTracking::SectionTracker	typeref:typename:ITracker &
currentTracker	tests/catch.hpp	/^        ITracker& currentTracker() {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:ITracker &
custom	tests/catch.hpp	/^  static Approx custom() {$/;"	f	class:Catch::Detail::Approx	typeref:typename:Approx
data	tests/ReadTests.cpp	/^        std::string data = f.Get();$/;"	v	typeref:typename:std::string
data	tests/TestInterface.cpp	/^        std::string data = f.Get();$/;"	v	typeref:typename:std::string
data	tests/catch.hpp	/^            std::string data;$/;"	m	struct:Clara::Parser::Token	typeref:typename:std::string
data	tests/catch.hpp	/^        char data[bufferSize];$/;"	m	class:Catch::StreamBufImpl	typeref:typename:char[]
dbgName	tests/catch.hpp	/^            std::string dbgName() const {$/;"	f	struct:Clara::CommandLine::Arg	typeref:typename:std::string
deleteAll	tests/catch.hpp	/^inline void deleteAll(ContainerT &container) {$/;"	f	namespace:Catch	typeref:typename:void
deleteAllValues	tests/catch.hpp	/^inline void deleteAllValues(AssociativeContainerT &container) {$/;"	f	namespace:Catch	typeref:typename:void
delta	tests/catch.hpp	/^  Totals delta(Totals const &prevTotals) const {$/;"	f	struct:Catch::Totals	typeref:typename:Totals
describe	tests/catch.hpp	/^            ArgBuilder& describe( std::string const& description ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:ArgBuilder &
description	tests/catch.hpp	/^        std::string description;$/;"	m	struct:Clara::CommonArgProperties	typeref:typename:std::string
description	tests/catch.hpp	/^  const char *description;$/;"	m	struct:Catch::NameAndDesc	typeref:typename:const char *
description	tests/catch.hpp	/^  std::string description;$/;"	m	struct:Catch::SectionInfo	typeref:typename:std::string
description	tests/catch.hpp	/^  std::string description;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:std::string
descriptor	file.h	/^    int descriptor;$/;"	m	class:File	typeref:typename:int
detail	tests/catch.hpp	/^            ArgBuilder& detail( std::string const& detail ) {$/;"	f	class:Clara::CommandLine::ArgBuilder	typeref:typename:ArgBuilder &
detail	tests/catch.hpp	/^        std::string detail;$/;"	m	struct:Clara::CommonArgProperties	typeref:typename:std::string
dimColour	tests/catch.hpp	/^            static Colour::Code dimColour() { return Colour::FileName; }$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:Colour::Code
dummy	tests/catch.hpp	/^    void Config::dummy() {}$/;"	f	class:Catch::Config	typeref:typename:void
durationInSeconds	tests/catch.hpp	/^        double durationInSeconds;$/;"	m	struct:Catch::SectionStats	typeref:typename:double
durationInSeconds	tests/catch.hpp	/^  double durationInSeconds;$/;"	m	struct:Catch::SectionEndInfo	typeref:typename:double
empty	tests/catch.hpp	/^    bool SourceLineInfo::empty() const {$/;"	f	class:Catch::SourceLineInfo	typeref:typename:bool
encodeTo	tests/catch.hpp	/^        void encodeTo( std::ostream& os ) const {$/;"	f	class:Catch::XmlEncode	typeref:typename:void
end	tests/catch.hpp	/^        const_iterator end() const { return lines.end(); }$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:const_iterator
end	tests/catch.hpp	/^        const_iterator end() const { return lines.end(); }$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:const_iterator
endElement	tests/catch.hpp	/^        XmlWriter& endElement() {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
endExpression	tests/catch.hpp	/^    void ResultBuilder::endExpression() {$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
endExpression	tests/catch.hpp	/^  void endExpression() {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:void
endRun	tests/catch.hpp	/^        void endRun() {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:void
endsWith	tests/catch.hpp	/^    bool endsWith( std::string const& s, std::string const& suffix ) {$/;"	f	namespace:Catch	typeref:typename:bool
enforceNoDuplicateTestCases	tests/catch.hpp	/^    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {$/;"	f	namespace:Catch	typeref:typename:void
enforceNotReservedTag	tests/catch.hpp	/^    inline void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo )/;"	f	namespace:Catch	typeref:typename:void
ensureTagClosed	tests/catch.hpp	/^        void ensureTagClosed() {$/;"	f	class:Catch::XmlWriter	typeref:typename:void
epsilon	tests/catch.hpp	/^  Approx &epsilon(double newEpsilon) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:Approx &
evaluate	tests/catch.hpp	/^  static bool evaluate(T1 const &lhs, T2 const &rhs) {$/;"	f	struct:Catch::Internal::Evaluator	typeref:typename:bool
exceptionTranslateFunction	tests/catch.hpp	/^typedef std::string(*exceptionTranslateFunction)();$/;"	t	namespace:Catch	typeref:typename:std::string (*)()
expandAliases	tests/catch.hpp	/^    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {$/;"	f	class:Catch::TagAliasRegistry	typeref:typename:std::string
expectedToFail	tests/catch.hpp	/^    bool TestCaseInfo::expectedToFail() const {$/;"	f	class:Catch::TestCaseInfo	typeref:typename:bool
extractClassName	tests/catch.hpp	/^    inline std::string extractClassName( std::string const& classOrQualifiedMethodName ) {$/;"	f	namespace:Catch	typeref:typename:std::string
f	tests/FileOpenTests.cpp	/^        File f;$/;"	v	typeref:typename:File
f	tests/ReadTests.cpp	/^        File f;$/;"	v	typeref:typename:File
f	tests/TestInterface.cpp	/^        File f;$/;"	v	typeref:typename:File
fail	tests/catch.hpp	/^        virtual void fail() CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:void
failed	tests/catch.hpp	/^  std::size_t failed;$/;"	m	struct:Catch::Counts	typeref:typename:std::size_t
failedButOk	tests/catch.hpp	/^  std::size_t failedButOk;$/;"	m	struct:Catch::Counts	typeref:typename:std::size_t
failedString	tests/catch.hpp	/^            static const char* failedString() { return "FAILED"; }$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:const char *
failedString	tests/catch.hpp	/^            static const char* failedString() { return "failed"; }$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:const char *
fatal	tests/catch.hpp	/^    inline void fatal( std::string const& message, int exitCode ) {$/;"	f	namespace:Catch	typeref:typename:void
file	tests/catch.hpp	/^  std::string file;$/;"	m	struct:Catch::SourceLineInfo	typeref:typename:std::string
file_path	tests/FileOpenTests.cpp	/^        const char *file_path = "..\/data\/file";$/;"	v	typeref:typename:const char *
file_path	tests/FileOpenTests.cpp	/^        std::string file_path = "..\/data\/file";$/;"	v	typeref:typename:std::string
file_path	tests/FileOpenTests.cpp	/^        std::string file_path = "..\/data\/i_dont_exist";$/;"	v	typeref:typename:std::string
file_path	tests/ReadTests.cpp	/^        const char *file_path = "..\/data\/empty";$/;"	v	typeref:typename:const char *
file_path	tests/ReadTests.cpp	/^        const char *file_path = "..\/data\/file";$/;"	v	typeref:typename:const char *
file_path	tests/TestInterface.cpp	/^        const char *file_path = "..\/data\/empty";$/;"	v	typeref:typename:const char *
file_path	tests/TestInterface.cpp	/^        const char *file_path = "..\/data\/file";$/;"	v	typeref:typename:const char *
file_path	tests/TestInterface.cpp	/^        std::string file_path = "..\/data\/file";$/;"	v	typeref:typename:std::string
file_path	tests/TestInterface.cpp	/^        std::string file_path = "..\/data\/i_dont_exist";$/;"	v	typeref:typename:std::string
file_stat	file.h	/^    struct stat file_stat;$/;"	m	class:File	typeref:struct:stat
filenamesAsTags	tests/catch.hpp	/^        bool filenamesAsTags;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
filterTests	tests/catch.hpp	/^    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& t/;"	f	namespace:Catch	typeref:typename:std::vector<TestCase>
find	tests/catch.hpp	/^    Option<TagAlias> TagAliasRegistry::find( std::string const& alias ) const {$/;"	f	class:Catch::TagAliasRegistry	typeref:typename:Option<TagAlias>
findChild	tests/catch.hpp	/^        virtual ITracker* findChild( std::string const& name ) CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:ITracker *
findGeneratorsForCurrentTest	tests/catch.hpp	/^        IGeneratorsForTest* findGeneratorsForCurrentTest() {$/;"	f	class:Catch::Context	typeref:typename:IGeneratorsForTest *
findMax	tests/catch.hpp	/^        static std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:std::size_t &
forceColour	tests/catch.hpp	/^    inline void forceColour( ConfigData& config ) {$/;"	f	namespace:Catch	typeref:typename:void
fpToString	tests/catch.hpp	/^std::string fpToString( T value, int precision ) {$/;"	f	namespace:Catch	typeref:typename:std::string
from	tests/catch.hpp	/^        std::size_t from;$/;"	m	class:Clara::Parser	typeref:typename:std::size_t
fs	tests/ReadTests.cpp	/^        struct stat fs;$/;"	v	typeref:struct:stat
fs	tests/TestInterface.cpp	/^        struct stat fs;$/;"	v	typeref:struct:stat
fullConfig	tests/catch.hpp	/^        Ptr<IConfig const> fullConfig() const { return m_fullConfig; }$/;"	f	struct:Catch::ReporterConfig	typeref:typename:Ptr<IConfig const>
function	tests/catch.hpp	/^            void (*function)( C& );$/;"	m	struct:Clara::Detail::BoundUnaryFunction	typeref:typename:void (*)(C &)
function	tests/catch.hpp	/^            void (*function)( C&, T );$/;"	m	struct:Clara::Detail::BoundBinaryFunction	typeref:typename:void (*)(C &,T)
functionObj	tests/catch.hpp	/^            IArgFunction<ConfigT>* functionObj;$/;"	m	class:Clara::Detail::BoundArgFunction	typeref:typename:IArgFunction<ConfigT> *
generator	tests/catch.hpp	/^      const IGenerator<T> *generator = *it;$/;"	m	class:Catch::CompositeGenerator	typeref:typename:const IGenerator<T> *
get	tests/catch.hpp	/^    ITagAliasRegistry const& ITagAliasRegistry::get() { return TagAliasRegistry::get(); }$/;"	f	class:Catch::ITagAliasRegistry	typeref:typename:ITagAliasRegistry const &
get	tests/catch.hpp	/^    TagAliasRegistry& TagAliasRegistry::get() {$/;"	f	class:Catch::TagAliasRegistry	typeref:typename:TagAliasRegistry &
get	tests/catch.hpp	/^  T *get() const { return m_p; }$/;"	f	class:Catch::Ptr	typeref:typename:T *
getAllTestCasesSorted	tests/catch.hpp	/^    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {$/;"	f	namespace:Catch	typeref:typename:std::vector<TestCase> const &
getAllTests	tests/catch.hpp	/^        virtual std::vector<TestCase> const& getAllTests() const {$/;"	f	class:Catch::TestRegistry	typeref:typename:std::vector<TestCase> const &
getAllTestsSorted	tests/catch.hpp	/^        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const {$/;"	f	class:Catch::TestRegistry	typeref:typename:std::vector<TestCase> const &
getAnnotation	tests/catch.hpp	/^        inline std::string getAnnotation(   Class cls,$/;"	f	namespace:Catch::Detail	typeref:typename:std::string
getConfig	tests/catch.hpp	/^        virtual Ptr<IConfig const> getConfig() const {$/;"	f	class:Catch::Context	typeref:typename:Ptr<IConfig const>
getCurrentContext	tests/catch.hpp	/^    IContext& getCurrentContext() {$/;"	f	namespace:Catch	typeref:typename:IContext &
getCurrentIndex	tests/catch.hpp	/^        std::size_t getCurrentIndex() const {$/;"	f	struct:Catch::GeneratorInfo	typeref:typename:std::size_t
getCurrentMutableContext	tests/catch.hpp	/^    IMutableContext& getCurrentMutableContext() {$/;"	f	namespace:Catch	typeref:typename:IMutableContext &
getCurrentTestName	tests/catch.hpp	/^        virtual std::string getCurrentTestName() const {$/;"	f	class:Catch::RunContext	typeref:typename:std::string
getCurrentTicks	tests/catch.hpp	/^        uint64_t getCurrentTicks() {$/;"	f	namespace:Catch::__anond33fe2000710	typeref:typename:uint64_t
getDescription	tests/catch.hpp	/^            virtual std::string getDescription() const {$/;"	f	class:Catch::LegacyReporterRegistrar::ReporterFactory	typeref:typename:std::string
getDescription	tests/catch.hpp	/^            virtual std::string getDescription() const {$/;"	f	class:Catch::ListenerRegistrar::ListenerFactory	typeref:typename:std::string
getDescription	tests/catch.hpp	/^            virtual std::string getDescription() const {$/;"	f	class:Catch::ReporterRegistrar::ReporterFactory	typeref:typename:std::string
getDescription	tests/catch.hpp	/^        static std::string getDescription() {$/;"	f	class:Catch::JunitReporter	typeref:typename:std::string
getDescription	tests/catch.hpp	/^        static std::string getDescription() {$/;"	f	class:Catch::XmlReporter	typeref:typename:std::string
getDescription	tests/catch.hpp	/^        static std::string getDescription() {$/;"	f	struct:Catch::CompactReporter	typeref:typename:std::string
getDescription	tests/catch.hpp	/^        static std::string getDescription() {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:std::string
getElapsedMicroseconds	tests/catch.hpp	/^    unsigned int Timer::getElapsedMicroseconds() const {$/;"	f	class:Catch::Timer	typeref:typename:unsigned int
getElapsedMilliseconds	tests/catch.hpp	/^    unsigned int Timer::getElapsedMilliseconds() const {$/;"	f	class:Catch::Timer	typeref:typename:unsigned int
getElapsedSeconds	tests/catch.hpp	/^    double Timer::getElapsedSeconds() const {$/;"	f	class:Catch::Timer	typeref:typename:double
getExpandedExpression	tests/catch.hpp	/^    std::string AssertionResult::getExpandedExpression() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:std::string
getExpression	tests/catch.hpp	/^    std::string AssertionResult::getExpression() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:std::string
getExpressionInMacro	tests/catch.hpp	/^    std::string AssertionResult::getExpressionInMacro() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:std::string
getFilename	tests/catch.hpp	/^        std::string const& getFilename() const {$/;"	f	class:Catch::Config	typeref:typename:std::string const &
getGeneratorIndex	tests/catch.hpp	/^        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) {$/;"	f	class:Catch::Context	typeref:typename:size_t
getGeneratorInfo	tests/catch.hpp	/^        IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) {$/;"	f	class:Catch::GeneratorsForTest	typeref:typename:IGeneratorInfo &
getGeneratorsForCurrentTest	tests/catch.hpp	/^        IGeneratorsForTest& getGeneratorsForCurrentTest() {$/;"	f	class:Catch::Context	typeref:typename:IGeneratorsForTest &
getLastResult	tests/catch.hpp	/^        virtual const AssertionResult* getLastResult() const {$/;"	f	class:Catch::RunContext	typeref:typename:const AssertionResult *
getLineOfChars	tests/catch.hpp	/^    char const* getLineOfChars() {$/;"	f	namespace:Catch	typeref:typename:char const *
getMessage	tests/catch.hpp	/^    std::string AssertionResult::getMessage() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:std::string
getMutableRegistryHub	tests/catch.hpp	/^    IMutableRegistryHub& getMutableRegistryHub() {$/;"	f	namespace:Catch	typeref:typename:IMutableRegistryHub &
getName	tests/catch.hpp	/^struct OperatorTraits { static const char *getName() { return "*error*"; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getName	tests/catch.hpp	/^struct OperatorTraits<IsEqualTo> { static const char *getName() { return "=="; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getName	tests/catch.hpp	/^struct OperatorTraits<IsGreaterThan> { static const char *getName() { return ">"; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getName	tests/catch.hpp	/^struct OperatorTraits<IsGreaterThanOrEqualTo> { static const char *getName() { return ">="; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getName	tests/catch.hpp	/^struct OperatorTraits<IsLessThan> { static const char *getName() { return "<"; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getName	tests/catch.hpp	/^struct OperatorTraits<IsLessThanOrEqualTo> { static const char *getName() { return "<="; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getName	tests/catch.hpp	/^struct OperatorTraits<IsNotEqualTo> { static const char *getName() { return "!="; }};$/;"	f	struct:Catch::Internal::OperatorTraits	typeref:typename:const char *
getPreferences	tests/catch.hpp	/^        virtual ReporterPreferences getPreferences() const {$/;"	f	struct:Catch::CompactReporter	typeref:typename:ReporterPreferences
getPreferences	tests/catch.hpp	/^    ReporterPreferences LegacyReporterAdapter::getPreferences() const {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:ReporterPreferences
getProcessName	tests/catch.hpp	/^        std::string getProcessName() const { return m_data.processName; }$/;"	f	class:Catch::Config	typeref:typename:std::string
getRegistryHub	tests/catch.hpp	/^    IRegistryHub& getRegistryHub() {$/;"	f	namespace:Catch	typeref:typename:IRegistryHub &
getReporterNames	tests/catch.hpp	/^        std::vector<std::string> getReporterNames() const { return m_data.reporterNames; }$/;"	f	class:Catch::Config	typeref:typename:std::vector<std::string>
getResultCapture	tests/catch.hpp	/^        virtual IResultCapture* getResultCapture() {$/;"	f	class:Catch::Context	typeref:typename:IResultCapture *
getResultCapture	tests/catch.hpp	/^    IResultCapture& getResultCapture() {$/;"	f	namespace:Catch	typeref:typename:IResultCapture &
getResultType	tests/catch.hpp	/^    ResultWas::OfType AssertionResult::getResultType() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:ResultWas::OfType
getRunner	tests/catch.hpp	/^        virtual IRunner* getRunner() {$/;"	f	class:Catch::Context	typeref:typename:IRunner *
getSourceInfo	tests/catch.hpp	/^    SourceLineInfo AssertionResult::getSourceInfo() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:SourceLineInfo
getTestCaseInfo	tests/catch.hpp	/^    TestCaseInfo const& TestCase::getTestCaseInfo() const$/;"	f	class:Catch::TestCase	typeref:typename:TestCaseInfo const &
getTestMacroName	tests/catch.hpp	/^    std::string AssertionResult::getTestMacroName() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:std::string
getTheRegistryHub	tests/catch.hpp	/^        inline RegistryHub*& getTheRegistryHub() {$/;"	f	namespace:Catch::__anond33fe2000210	typeref:typename:RegistryHub * &
getValue	tests/catch.hpp	/^  virtual T getValue(std::size_t index) const {$/;"	f	class:Catch::BetweenGenerator	typeref:typename:T
getValue	tests/catch.hpp	/^  virtual T getValue(std::size_t index) const {$/;"	f	class:Catch::ValuesGenerator	typeref:typename:T
globalCount	tests/catch.hpp	/^    unsigned int MessageInfo::globalCount = 0;$/;"	m	class:Catch::MessageInfo	typeref:typename:unsigned int
globalCount	tests/catch.hpp	/^  static unsigned int globalCount;$/;"	m	struct:Catch::MessageInfo	typeref:typename:unsigned int
groupIndex	tests/catch.hpp	/^        std::size_t groupIndex;$/;"	m	struct:Catch::GroupInfo	typeref:typename:std::size_t
groupInfo	tests/catch.hpp	/^        GroupInfo groupInfo;$/;"	m	struct:Catch::TestGroupStats	typeref:typename:GroupInfo
groupsCounts	tests/catch.hpp	/^        std::size_t groupsCounts;$/;"	m	struct:Catch::GroupInfo	typeref:typename:std::size_t
handleFatalErrorCondition	tests/catch.hpp	/^        virtual void handleFatalErrorCondition( std::string const& message ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
handleMaybeShortOpt	tests/catch.hpp	/^        Mode handleMaybeShortOpt( std::size_t i, char c ) {$/;"	f	class:Clara::Parser	typeref:typename:Mode
handleMode	tests/catch.hpp	/^        Mode handleMode( std::size_t i, char c, std::string const& arg, std::vector<Token>& toke/;"	f	class:Clara::Parser	typeref:typename:Mode
handleNone	tests/catch.hpp	/^        Mode handleNone( std::size_t i, char c ) {$/;"	f	class:Clara::Parser	typeref:typename:Mode
handleOpt	tests/catch.hpp	/^        Mode handleOpt( std::size_t i, char c, std::string const& arg, std::vector<Token>& token/;"	f	class:Clara::Parser	typeref:typename:Mode
handlePositional	tests/catch.hpp	/^        Mode handlePositional( std::size_t i, char c, std::string const& arg, std::vector<Token>/;"	f	class:Clara::Parser	typeref:typename:Mode
handleResult	tests/catch.hpp	/^    void ResultBuilder::handleResult( AssertionResult const& result )$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
handleSignal	tests/catch.hpp	/^        static void handleSignal( int sig ) {$/;"	f	struct:Catch::FatalConditionHandler	typeref:typename:void
handleUnfinishedSections	tests/catch.hpp	/^        void handleUnfinishedSections() {$/;"	f	class:Catch::RunContext	typeref:typename:void
hasExpandedExpression	tests/catch.hpp	/^    bool AssertionResult::hasExpandedExpression() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:bool
hasExpression	tests/catch.hpp	/^    bool AssertionResult::hasExpression() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:bool
hasFilters	tests/catch.hpp	/^        bool hasFilters() const {$/;"	f	class:Catch::TestSpec	typeref:typename:bool
hasLongName	tests/catch.hpp	/^        bool hasLongName( std::string const& _longName ) const {$/;"	f	struct:Clara::OptionArgProperties	typeref:typename:bool
hasMessage	tests/catch.hpp	/^    bool AssertionResult::hasMessage() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:bool
hasShortName	tests/catch.hpp	/^        bool hasShortName( std::string const& shortName ) const {$/;"	f	struct:Clara::OptionArgProperties	typeref:typename:bool
hexThreshold	tests/catch.hpp	/^        const int hexThreshold = 255;$/;"	v	namespace:Catch::Detail::__anond33fe2000810	typeref:typename:const int
id	tests/catch.hpp	/^    struct SignalDefs { int id; const char* name; };$/;"	m	struct:Catch::SignalDefs	typeref:typename:int
inQuotes	tests/catch.hpp	/^        bool inQuotes;$/;"	m	class:Clara::Parser	typeref:typename:bool
includeSuccessfulResults	tests/catch.hpp	/^        virtual bool includeSuccessfulResults() const   { return m_data.showSuccessfulTests; }$/;"	f	class:Catch::Config	typeref:typename:bool
indent	tests/catch.hpp	/^        std::size_t indent;         \/\/ indent of subsequent lines, or all if initialIndent is /;"	m	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:std::size_t
indent	tests/catch.hpp	/^        std::size_t indent;         \/\/ indent of subsequent lines, or all if initialIndent is /;"	m	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:std::size_t
index	tests/catch.hpp	/^        int index() const { return m_index; }$/;"	f	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:int
index	tests/catch.hpp	/^    for (size_t index = 0; it != itEnd; ++it) {$/;"	m	class:Catch::CompositeGenerator	typeref:typename:size_t
infoMessages	tests/catch.hpp	/^        std::vector<MessageInfo> infoMessages;$/;"	m	struct:Catch::AssertionStats	typeref:typename:std::vector<MessageInfo>
initialIndent	tests/catch.hpp	/^        std::size_t initialIndent;  \/\/ indent of first line, or npos$/;"	m	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:std::size_t
initialIndent	tests/catch.hpp	/^        std::size_t initialIndent;  \/\/ indent of first line, or npos$/;"	m	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:std::size_t
initialize	file.cpp	/^File::STATUS File::initialize() {$/;"	f	class:File	typeref:typename:File::STATUS
instance	tests/catch.hpp	/^            static IColourImpl* instance() {$/;"	f	struct:Catch::__anond33fe2000410::NoColourImpl	typeref:typename:IColourImpl *
instance	tests/catch.hpp	/^        static IColourImpl* instance() {$/;"	f	class:Catch::__anond33fe2000610::PosixColourImpl	typeref:typename:IColourImpl *
instance	tests/catch.hpp	/^        static TrackerContext& instance() {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:TrackerContext &
invoke	tests/catch.hpp	/^        virtual void invoke() const {$/;"	f	class:Catch::FreeFunctionTestCase	typeref:typename:void
invoke	tests/catch.hpp	/^        virtual void invoke() const {$/;"	f	class:Catch::OcMethod	typeref:typename:void
invoke	tests/catch.hpp	/^    void TestCase::invoke() const {$/;"	f	class:Catch::TestCase	typeref:typename:void
invoke	tests/catch.hpp	/^  virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase	typeref:typename:void
invokeActiveTestCase	tests/catch.hpp	/^        void invokeActiveTestCase() {$/;"	f	class:Catch::RunContext	typeref:typename:void
isDebuggerActive	tests/catch.hpp	/^        bool isDebuggerActive() {$/;"	f	namespace:Catch	typeref:typename:bool
isDebuggerActive	tests/catch.hpp	/^        bool isDebuggerActive(){$/;"	f	namespace:Catch	typeref:typename:bool
isDebuggerActive	tests/catch.hpp	/^       inline bool isDebuggerActive() { return false; }$/;"	f	namespace:Catch	typeref:typename:bool
isFalseTest	tests/catch.hpp	/^inline bool isFalseTest(int flags) { return (flags & ResultDisposition::FalseTest) != 0; }$/;"	f	namespace:Catch	typeref:typename:bool
isFixedPositional	tests/catch.hpp	/^        bool isFixedPositional() const {$/;"	f	struct:Clara::PositionalArgProperties	typeref:typename:bool
isHidden	tests/catch.hpp	/^    bool TestCaseInfo::isHidden() const {$/;"	f	class:Catch::TestCaseInfo	typeref:typename:bool
isJustInfo	tests/catch.hpp	/^inline bool isJustInfo(int flags) {$/;"	f	namespace:Catch	typeref:typename:bool
isOk	tests/catch.hpp	/^    bool AssertionResult::isOk() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:bool
isOk	tests/catch.hpp	/^inline bool isOk(ResultWas::OfType resultType) {$/;"	f	namespace:Catch	typeref:typename:bool
isReservedTag	tests/catch.hpp	/^    inline bool isReservedTag( std::string const& tag ) {$/;"	f	namespace:Catch	typeref:typename:bool
isSet	tests/catch.hpp	/^            bool isSet() const {$/;"	f	class:Clara::Detail::BoundArgFunction	typeref:typename:bool
isTrue	tests/catch.hpp	/^inline bool isTrue(bool value) { return value; }$/;"	f	namespace:Catch	typeref:typename:bool
it	tests/catch.hpp	/^        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();$/;"	m	class:Catch::MultipleReporters	typeref:typename:Reporters::const_iterator
it	tests/catch.hpp	/^    typename std::vector<const IGenerator<T> *>::const_iterator it = m_composed.begin();$/;"	m	class:Catch::CompositeGenerator	typeref:typename:std::vector<const IGenerator<T> * >::const_iterator
itEnd	tests/catch.hpp	/^        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();$/;"	m	class:Catch::MultipleReporters	typeref:typename:Reporters::const_iterator
itEnd	tests/catch.hpp	/^    typename std::vector<const IGenerator<T> *>::const_iterator itEnd = m_composed.end();$/;"	m	class:Catch::CompositeGenerator	typeref:typename:std::vector<const IGenerator<T> * >::const_iterator
itMessage	tests/catch.hpp	/^            std::vector<MessageInfo>::const_iterator itMessage;$/;"	m	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:std::vector<MessageInfo>::const_iterator
label	tests/catch.hpp	/^            std::string label;$/;"	m	struct:Catch::ConsoleReporter::SummaryColumn	typeref:typename:std::string
last	tests/catch.hpp	/^        std::string const& last() const { return lines.back(); }$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string const &
last	tests/catch.hpp	/^        std::string const& last() const { return lines.back(); }$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string const &
lazyPrint	tests/catch.hpp	/^        void lazyPrint() {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
lazyPrintGroupInfo	tests/catch.hpp	/^        void lazyPrintGroupInfo() {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
lazyPrintRunInfo	tests/catch.hpp	/^        void lazyPrintRunInfo() {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
lcaseTags	tests/catch.hpp	/^  std::set <std::string> lcaseTags;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:std::set<std::string>
lhs	tests/catch.hpp	/^    std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	typeref:typename:std::string
libraryVersion	tests/catch.hpp	/^    Version libraryVersion( 1, 5, 4, "", 0 );$/;"	v	namespace:Catch	typeref:typename:Version
line	tests/catch.hpp	/^  std::size_t line;$/;"	m	struct:Catch::SourceLineInfo	typeref:typename:std::size_t
lineInfo	tests/catch.hpp	/^  SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo	typeref:typename:SourceLineInfo
lineInfo	tests/catch.hpp	/^  SourceLineInfo lineInfo;$/;"	m	struct:Catch::MessageInfo	typeref:typename:SourceLineInfo
lineInfo	tests/catch.hpp	/^  SourceLineInfo lineInfo;$/;"	m	struct:Catch::SectionInfo	typeref:typename:SourceLineInfo
lineInfo	tests/catch.hpp	/^  SourceLineInfo lineInfo;$/;"	m	struct:Catch::TagAlias	typeref:typename:SourceLineInfo
lineInfo	tests/catch.hpp	/^  SourceLineInfo lineInfo;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:SourceLineInfo
lines	tests/catch.hpp	/^        std::vector<std::string> lines;$/;"	m	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::vector<std::string>
lines	tests/catch.hpp	/^        std::vector<std::string> lines;$/;"	m	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::vector<std::string>
list	tests/catch.hpp	/^    inline Option<std::size_t> list( Config const& config ) {$/;"	f	namespace:Catch	typeref:typename:Option<std::size_t>
listReporters	tests/catch.hpp	/^        bool listReporters() const { return m_data.listReporters; }$/;"	f	class:Catch::Config	typeref:typename:bool
listReporters	tests/catch.hpp	/^        bool listReporters;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
listReporters	tests/catch.hpp	/^    inline std::size_t listReporters( Config const& \/*config*\/ ) {$/;"	f	namespace:Catch	typeref:typename:std::size_t
listTags	tests/catch.hpp	/^        bool listTags() const { return m_data.listTags; }$/;"	f	class:Catch::Config	typeref:typename:bool
listTags	tests/catch.hpp	/^        bool listTags;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
listTags	tests/catch.hpp	/^    inline std::size_t listTags( Config const& config ) {$/;"	f	namespace:Catch	typeref:typename:std::size_t
listTestNamesOnly	tests/catch.hpp	/^        bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }$/;"	f	class:Catch::Config	typeref:typename:bool
listTestNamesOnly	tests/catch.hpp	/^        bool listTestNamesOnly;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
listTests	tests/catch.hpp	/^        bool listTests() const { return m_data.listTests; }$/;"	f	class:Catch::Config	typeref:typename:bool
listTests	tests/catch.hpp	/^        bool listTests;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
listTests	tests/catch.hpp	/^    inline std::size_t listTests( Config const& config ) {$/;"	f	namespace:Catch	typeref:typename:std::size_t
listTestsNamesOnly	tests/catch.hpp	/^    inline std::size_t listTestsNamesOnly( Config const& config ) {$/;"	f	namespace:Catch	typeref:typename:std::size_t
loadTestNamesFromFile	tests/catch.hpp	/^    inline void loadTestNamesFromFile( ConfigData& config, std::string const& _filename ) {$/;"	f	namespace:Catch	typeref:typename:void
longName	tests/catch.hpp	/^        std::string longName;$/;"	m	struct:Clara::OptionArgProperties	typeref:typename:std::string
m_activeSections	tests/catch.hpp	/^        std::vector<ITracker*> m_activeSections;$/;"	m	class:Catch::RunContext	typeref:typename:std::vector<ITracker * >
m_activeTestCase	tests/catch.hpp	/^        TestCase const* m_activeTestCase;$/;"	m	class:Catch::RunContext	typeref:typename:TestCase const *
m_arg	tests/catch.hpp	/^            Arg* m_arg;$/;"	m	class:Clara::CommandLine::ArgBuilder	typeref:typename:Arg *
m_arg	tests/catch.hpp	/^        std::string m_arg;$/;"	m	class:Catch::TestSpecParser	typeref:typename:std::string
m_assertionInfo	tests/catch.hpp	/^  AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder	typeref:typename:AssertionInfo
m_assertions	tests/catch.hpp	/^        std::vector<AssertionStats> m_assertions;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::vector<AssertionStats>
m_assertions	tests/catch.hpp	/^  Counts m_assertions;$/;"	m	class:Catch::Section	typeref:typename:Counts
m_boundProcessName	tests/catch.hpp	/^        Detail::BoundArgFunction<ConfigT> m_boundProcessName;$/;"	m	class:Clara::CommandLine	typeref:typename:Detail::BoundArgFunction<ConfigT>
m_caseSensitivity	tests/catch.hpp	/^        CaseSensitive::Choice m_caseSensitivity;$/;"	m	class:Catch::WildcardPattern	typeref:typename:CaseSensitive::Choice
m_caseSensitivity	tests/catch.hpp	/^  CaseSensitive::Choice m_caseSensitivity;$/;"	m	struct:Catch::Matchers::Impl::StdString::CasedString	typeref:typename:CaseSensitive::Choice
m_children	tests/catch.hpp	/^        Children m_children;$/;"	m	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:Children
m_cli	tests/catch.hpp	/^        Clara::CommandLine<ConfigData> m_cli;$/;"	m	class:Catch::Session	typeref:typename:Clara::CommandLine<ConfigData>
m_cls	tests/catch.hpp	/^        Class m_cls;$/;"	m	class:Catch::OcMethod	typeref:typename:Class
m_composed	tests/catch.hpp	/^  std::vector<const IGenerator<T> *> m_composed;$/;"	m	class:Catch::CompositeGenerator	typeref:typename:std::vector<const IGenerator<T> * >
m_config	tests/catch.hpp	/^        Ptr<Config> m_config;$/;"	m	class:Catch::Session	typeref:typename:Ptr<Config>
m_config	tests/catch.hpp	/^        Ptr<IConfig const> m_config;$/;"	m	class:Catch::Context	typeref:typename:Ptr<IConfig const>
m_config	tests/catch.hpp	/^        Ptr<IConfig const> m_config;$/;"	m	class:Catch::RunContext	typeref:typename:Ptr<IConfig const>
m_config	tests/catch.hpp	/^        Ptr<IConfig const> m_config;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:Ptr<IConfig const>
m_config	tests/catch.hpp	/^        Ptr<IConfig const> m_config;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:Ptr<IConfig const>
m_configData	tests/catch.hpp	/^        ConfigData m_configData;$/;"	m	class:Catch::Session	typeref:typename:ConfigData
m_context	tests/catch.hpp	/^        IMutableContext& m_context;$/;"	m	class:Catch::RunContext	typeref:typename:IMutableContext &
m_count	tests/catch.hpp	/^  std::size_t m_count;$/;"	m	struct:Catch::pluralise	typeref:typename:std::size_t
m_ctx	tests/catch.hpp	/^        TrackerContext& m_ctx;$/;"	m	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:TrackerContext &
m_currentFilter	tests/catch.hpp	/^        TestSpec::Filter m_currentFilter;$/;"	m	class:Catch::TestSpecParser	typeref:typename:TestSpec::Filter
m_currentIndex	tests/catch.hpp	/^        std::size_t m_currentIndex;$/;"	m	struct:Catch::GeneratorInfo	typeref:typename:std::size_t
m_currentSectionTracker	tests/catch.hpp	/^        ITracker* m_currentSectionTracker;$/;"	m	class:Catch::RunContext	typeref:typename:ITracker *
m_currentSortOrder	tests/catch.hpp	/^        mutable RunTests::InWhatOrder m_currentSortOrder;$/;"	m	class:Catch::TestRegistry	typeref:typename:RunTests::InWhatOrder
m_currentTracker	tests/catch.hpp	/^        ITracker* m_currentTracker;$/;"	m	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:ITracker *
m_data	tests/catch.hpp	/^        ConfigData m_data;$/;"	m	class:Catch::Config	typeref:typename:ConfigData
m_data	tests/catch.hpp	/^  AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder	typeref:typename:AssertionResultData
m_data	tests/catch.hpp	/^  CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::Contains	typeref:typename:CasedString
m_data	tests/catch.hpp	/^  CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::EndsWith	typeref:typename:CasedString
m_data	tests/catch.hpp	/^  CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::Equals	typeref:typename:CasedString
m_data	tests/catch.hpp	/^  CasedString m_data;$/;"	m	struct:Catch::Matchers::Impl::StdString::StartsWith	typeref:typename:CasedString
m_deepestSection	tests/catch.hpp	/^        Ptr<SectionNode> m_deepestSection;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:Ptr<SectionNode>
m_epsilon	tests/catch.hpp	/^  double m_epsilon;$/;"	m	class:Catch::Detail::Approx	typeref:typename:double
m_exceptionTranslatorRegistry	tests/catch.hpp	/^            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;$/;"	m	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:ExceptionTranslatorRegistry
m_exclusion	tests/catch.hpp	/^        bool m_exclusion;$/;"	m	class:Catch::TestSpecParser	typeref:typename:bool
m_exprComponents	tests/catch.hpp	/^  } m_exprComponents;$/;"	m	class:Catch::ResultBuilder	typeref:struct:Catch::ResultBuilder::ExprComponents
m_fileInfo	tests/catch.hpp	/^  std::string m_fileInfo;$/;"	m	class:Catch::CompositeGenerator	typeref:typename:std::string
m_filters	tests/catch.hpp	/^        std::vector<Filter> m_filters;$/;"	m	class:Catch::TestSpec	typeref:typename:std::vector<Filter>
m_floatingArg	tests/catch.hpp	/^        ArgAutoPtr m_floatingArg;$/;"	m	class:Clara::CommandLine	typeref:typename:ArgAutoPtr
m_forWhat	tests/catch.hpp	/^        ForWhat m_forWhat;$/;"	m	class:Catch::XmlEncode	typeref:typename:ForWhat
m_from	tests/catch.hpp	/^  T m_from;$/;"	m	class:Catch::BetweenGenerator	typeref:typename:T
m_fullConfig	tests/catch.hpp	/^        Ptr<IConfig const> m_fullConfig;$/;"	m	struct:Catch::ReporterConfig	typeref:typename:Ptr<IConfig const>
m_fun	tests/catch.hpp	/^        TestFunction m_fun;$/;"	m	class:Catch::FreeFunctionTestCase	typeref:typename:TestFunction
m_functions	tests/catch.hpp	/^        std::vector<TestCase> m_functions;$/;"	m	class:Catch::TestRegistry	typeref:typename:std::vector<TestCase>
m_generatorsByName	tests/catch.hpp	/^        std::map<std::string, IGeneratorInfo*> m_generatorsByName;$/;"	m	class:Catch::GeneratorsForTest	typeref:typename:std::map<std::string,IGeneratorInfo * >
m_generatorsByTestName	tests/catch.hpp	/^        std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;$/;"	m	class:Catch::Context	typeref:typename:std::map<std::string,IGeneratorsForTest * >
m_generatorsInOrder	tests/catch.hpp	/^        std::vector<IGeneratorInfo*> m_generatorsInOrder;$/;"	m	class:Catch::GeneratorsForTest	typeref:typename:std::vector<IGeneratorInfo * >
m_headerPrinted	tests/catch.hpp	/^        bool m_headerPrinted;$/;"	m	struct:Catch::ConsoleReporter	typeref:typename:bool
m_highestSpecifiedArgPosition	tests/catch.hpp	/^        int m_highestSpecifiedArgPosition;$/;"	m	class:Clara::CommandLine	typeref:typename:int
m_indent	tests/catch.hpp	/^        std::string m_indent;$/;"	m	class:Catch::XmlWriter	typeref:typename:std::string
m_index	tests/catch.hpp	/^        int m_index;$/;"	m	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:int
m_info	tests/catch.hpp	/^  AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult	typeref:typename:AssertionInfo
m_info	tests/catch.hpp	/^  MessageInfo m_info;$/;"	m	class:Catch::ScopedMessage	typeref:typename:MessageInfo
m_info	tests/catch.hpp	/^  MessageInfo m_info;$/;"	m	struct:Catch::MessageBuilder	typeref:typename:MessageInfo
m_info	tests/catch.hpp	/^  SectionInfo m_info;$/;"	m	class:Catch::Section	typeref:typename:SectionInfo
m_isSet	tests/catch.hpp	/^        bool m_isSet;$/;"	m	struct:Catch::FatalConditionHandler	typeref:typename:bool
m_label	tests/catch.hpp	/^  std::string m_label;$/;"	m	struct:Catch::pluralise	typeref:typename:std::string
m_lastAssertionInfo	tests/catch.hpp	/^        AssertionInfo m_lastAssertionInfo;$/;"	m	class:Catch::RunContext	typeref:typename:AssertionInfo
m_lastResult	tests/catch.hpp	/^        AssertionResult m_lastResult;$/;"	m	class:Catch::RunContext	typeref:typename:AssertionResult
m_legacyReporter	tests/catch.hpp	/^        Ptr<IReporter> m_legacyReporter;$/;"	m	class:Catch::LegacyReporterAdapter	typeref:typename:Ptr<IReporter>
m_lhs	tests/catch.hpp	/^  T m_lhs;$/;"	m	class:Catch::ExpressionLhs	typeref:typename:T
m_lineInfo	tests/catch.hpp	/^  SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException	typeref:typename:SourceLineInfo
m_listeners	tests/catch.hpp	/^        Listeners m_listeners;$/;"	m	class:Catch::ReporterRegistry	typeref:typename:Listeners
m_matchers	tests/catch.hpp	/^  std::vector <Ptr<Matcher<ExpressionT> >> m_matchers;$/;"	m	class:Catch::Matchers::Impl::Generic::AllOf	typeref:typename:std::vector<Ptr<Matcher<ExpressionT>>>
m_matchers	tests/catch.hpp	/^  std::vector <Ptr<Matcher<ExpressionT> >> m_matchers;$/;"	m	class:Catch::Matchers::Impl::Generic::AnyOf	typeref:typename:std::vector<Ptr<Matcher<ExpressionT>>>
m_messages	tests/catch.hpp	/^        std::vector<MessageInfo> m_messages;$/;"	m	class:Catch::RunContext	typeref:typename:std::vector<MessageInfo>
m_mode	tests/catch.hpp	/^        Mode m_mode;$/;"	m	class:Catch::TestSpecParser	typeref:typename:Mode
m_moved	tests/catch.hpp	/^        bool m_moved;$/;"	m	struct:Catch::Colour	typeref:typename:bool
m_name	tests/catch.hpp	/^            std::string m_name;$/;"	m	class:Catch::TestCaseTracking::TrackerBase::TrackerHasName	typeref:typename:std::string
m_name	tests/catch.hpp	/^        std::string m_name;$/;"	m	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:std::string
m_name	tests/catch.hpp	/^  std::string m_name;$/;"	m	class:Catch::Section	typeref:typename:std::string
m_needsNewline	tests/catch.hpp	/^        bool m_needsNewline;$/;"	m	class:Catch::XmlWriter	typeref:typename:bool
m_ofs	tests/catch.hpp	/^        mutable std::ofstream m_ofs;$/;"	m	class:Catch::FileStream	typeref:typename:std::ofstream
m_options	tests/catch.hpp	/^        std::vector<Arg> m_options;$/;"	m	class:Clara::CommandLine	typeref:typename:std::vector<Arg>
m_os	tests/catch.hpp	/^        mutable std::ostream m_os;$/;"	m	class:Catch::CoutStream	typeref:typename:std::ostream
m_os	tests/catch.hpp	/^        mutable std::ostream m_os;$/;"	m	class:Catch::DebugOutStream	typeref:typename:std::ostream
m_os	tests/catch.hpp	/^        std::ostream* m_os;$/;"	m	class:Catch::XmlWriter	typeref:typename:std::ostream *
m_oss	tests/catch.hpp	/^        std::ostringstream m_oss;$/;"	m	class:Catch::StreamRedirect	typeref:typename:std::ostringstream
m_ostreamInit	tests/catch.hpp	/^        std::ios_base::Init m_ostreamInit; \/\/ Forces cout\/ cerr to be initialised$/;"	m	class:Catch::TestRegistry	typeref:typename:std::ios_base::Init
m_other	tests/catch.hpp	/^            SectionInfo const& m_other;$/;"	m	struct:Catch::CumulativeReporterBase::BySectionInfo	typeref:typename:SectionInfo const &
m_p	tests/catch.hpp	/^  T *m_p;$/;"	m	class:Catch::Ptr	typeref:typename:T *
m_parent	tests/catch.hpp	/^        ITracker* m_parent;$/;"	m	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:ITracker *
m_pattern	tests/catch.hpp	/^        std::string m_pattern;$/;"	m	class:Catch::WildcardPattern	typeref:typename:std::string
m_patterns	tests/catch.hpp	/^            std::vector<Ptr<Pattern> > m_patterns;$/;"	m	struct:Catch::TestSpec::Filter	typeref:typename:std::vector<Ptr<Pattern>>
m_pos	tests/catch.hpp	/^        std::size_t m_start, m_pos;$/;"	m	class:Catch::TestSpecParser	typeref:typename:std::size_t
m_positionalArgs	tests/catch.hpp	/^        std::map<int, Arg> m_positionalArgs;$/;"	m	class:Clara::CommandLine	typeref:typename:std::map<int,Arg>
m_prevBuf	tests/catch.hpp	/^        std::streambuf* m_prevBuf;$/;"	m	class:Catch::StreamRedirect	typeref:typename:std::streambuf *
m_rb	tests/catch.hpp	/^  ResultBuilder &m_rb;$/;"	m	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
m_rc	tests/catch.hpp	/^  mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl	typeref:typename:unsigned int
m_registry	tests/catch.hpp	/^        std::map<std::string, TagAlias> m_registry;$/;"	m	class:Catch::TagAliasRegistry	typeref:typename:std::map<std::string,TagAlias>
m_reporter	tests/catch.hpp	/^        Ptr<IStreamingReporter> m_reporter;$/;"	m	class:Catch::RunContext	typeref:typename:Ptr<IStreamingReporter>
m_reporterPrefs	tests/catch.hpp	/^        ReporterPreferences m_reporterPrefs;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:ReporterPreferences
m_reporterPrefs	tests/catch.hpp	/^        ReporterPreferences m_reporterPrefs;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:ReporterPreferences
m_reporterRegistry	tests/catch.hpp	/^            ReporterRegistry m_reporterRegistry;$/;"	m	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:ReporterRegistry
m_reporters	tests/catch.hpp	/^    Reporters m_reporters;$/;"	m	class:Catch::MultipleReporters	typeref:typename:Reporters
m_resultCapture	tests/catch.hpp	/^        IResultCapture* m_resultCapture;$/;"	m	class:Catch::Context	typeref:typename:IResultCapture *
m_resultData	tests/catch.hpp	/^  AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult	typeref:typename:AssertionResultData
m_rootSection	tests/catch.hpp	/^        Ptr<SectionNode> m_rootSection;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:Ptr<SectionNode>
m_rootTracker	tests/catch.hpp	/^        Ptr<ITracker> m_rootTracker;$/;"	m	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:Ptr<ITracker>
m_runInfo	tests/catch.hpp	/^        TestRunInfo m_runInfo;$/;"	m	class:Catch::RunContext	typeref:typename:TestRunInfo
m_runState	tests/catch.hpp	/^        CycleState m_runState;$/;"	m	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:CycleState
m_runState	tests/catch.hpp	/^        RunState m_runState;$/;"	m	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:RunState
m_runner	tests/catch.hpp	/^        IRunner* m_runner;$/;"	m	class:Catch::Context	typeref:typename:IRunner *
m_scale	tests/catch.hpp	/^  double m_scale;$/;"	m	class:Catch::Detail::Approx	typeref:typename:double
m_sectionDepth	tests/catch.hpp	/^        int m_sectionDepth;$/;"	m	class:Catch::XmlReporter	typeref:typename:int
m_sectionIncluded	tests/catch.hpp	/^  bool m_sectionIncluded;$/;"	m	class:Catch::Section	typeref:typename:bool
m_sectionStack	tests/catch.hpp	/^        std::vector<Ptr<SectionNode> > m_sectionStack;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::vector<Ptr<SectionNode>>
m_sectionStack	tests/catch.hpp	/^        std::vector<SectionInfo> m_sectionStack;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:std::vector<SectionInfo>
m_sections	tests/catch.hpp	/^        std::vector<std::vector<Ptr<SectionNode> > > m_sections;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::vector<std::vector<Ptr<SectionNode>>>
m_sel	tests/catch.hpp	/^        SEL m_sel;$/;"	m	class:Catch::OcMethod	typeref:typename:SEL
m_shouldDebugBreak	tests/catch.hpp	/^  bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder	typeref:typename:bool
m_shouldThrow	tests/catch.hpp	/^  bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder	typeref:typename:bool
m_size	tests/catch.hpp	/^        int m_size;$/;"	m	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:int
m_size	tests/catch.hpp	/^        std::size_t m_size;$/;"	m	struct:Catch::GeneratorInfo	typeref:typename:std::size_t
m_sortedFunctions	tests/catch.hpp	/^        mutable std::vector<TestCase> m_sortedFunctions;$/;"	m	class:Catch::TestRegistry	typeref:typename:std::vector<TestCase>
m_start	tests/catch.hpp	/^        std::size_t m_start, m_pos;$/;"	m	class:Catch::TestSpecParser	typeref:typename:std::size_t
m_str	tests/catch.hpp	/^        std::string m_str;$/;"	m	class:Catch::XmlEncode	typeref:typename:std::string
m_str	tests/catch.hpp	/^  std::string m_str;$/;"	m	struct:Catch::Matchers::Impl::StdString::CasedString	typeref:typename:std::string
m_stream	tests/catch.hpp	/^        std::auto_ptr<IStream const> m_stream;$/;"	m	class:Catch::Config	typeref:typename:std::auto_ptr<IStream const>
m_stream	tests/catch.hpp	/^        std::ostream& m_stream;$/;"	m	class:Catch::StreamRedirect	typeref:typename:std::ostream &
m_stream	tests/catch.hpp	/^        std::ostream* m_stream;$/;"	m	struct:Catch::ReporterConfig	typeref:typename:std::ostream *
m_stream	tests/catch.hpp	/^  CopyableStream m_stream;$/;"	m	class:Catch::ResultBuilder	typeref:typename:CopyableStream
m_stream	tests/catch.hpp	/^  std::ostringstream m_stream;$/;"	m	struct:Catch::MessageBuilder	typeref:typename:std::ostringstream
m_streamBuf	tests/catch.hpp	/^        std::auto_ptr<StreamBufBase> m_streamBuf;$/;"	m	class:Catch::DebugOutStream	typeref:typename:std::auto_ptr<StreamBufBase>
m_substr	tests/catch.hpp	/^                NSString* m_substr;$/;"	m	struct:Catch::Matchers::Impl::NSStringMatchers::StringHolder	typeref:typename:NSString *
m_tag	tests/catch.hpp	/^            std::string m_tag;$/;"	m	class:Catch::TestSpec::TagPattern	typeref:typename:std::string
m_tagAliases	tests/catch.hpp	/^        ITagAliasRegistry const* m_tagAliases;$/;"	m	class:Catch::TestSpecParser	typeref:typename:ITagAliasRegistry const *
m_tagIsOpen	tests/catch.hpp	/^        bool m_tagIsOpen;$/;"	m	class:Catch::XmlWriter	typeref:typename:bool
m_tags	tests/catch.hpp	/^        std::vector<std::string> m_tags;$/;"	m	class:Catch::XmlWriter	typeref:typename:std::vector<std::string>
m_targetString	tests/catch.hpp	/^        std::string& m_targetString;$/;"	m	class:Catch::StreamRedirect	typeref:typename:std::string &
m_testCaseRegistry	tests/catch.hpp	/^            TestRegistry m_testCaseRegistry;$/;"	m	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:TestRegistry
m_testCaseTimer	tests/catch.hpp	/^        Timer m_testCaseTimer;$/;"	m	class:Catch::XmlReporter	typeref:typename:Timer
m_testCaseTracker	tests/catch.hpp	/^        ITracker* m_testCaseTracker;$/;"	m	class:Catch::RunContext	typeref:typename:ITracker *
m_testCases	tests/catch.hpp	/^        std::vector<Ptr<TestCaseNode> > m_testCases;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::vector<Ptr<TestCaseNode>>
m_testGroups	tests/catch.hpp	/^        std::vector<Ptr<TestGroupNode> > m_testGroups;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::vector<Ptr<TestGroupNode>>
m_testRuns	tests/catch.hpp	/^        std::vector<Ptr<TestRunNode> > m_testRuns;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::vector<Ptr<TestRunNode>>
m_testSpec	tests/catch.hpp	/^        TestSpec m_testSpec;$/;"	m	class:Catch::Config	typeref:typename:TestSpec
m_testSpec	tests/catch.hpp	/^        TestSpec m_testSpec;$/;"	m	class:Catch::TestSpecParser	typeref:typename:TestSpec
m_throwOnUnrecognisedTokens	tests/catch.hpp	/^        bool m_throwOnUnrecognisedTokens;$/;"	m	class:Clara::CommandLine	typeref:typename:bool
m_ticks	tests/catch.hpp	/^  uint64_t m_ticks;$/;"	m	class:Catch::Timer	typeref:typename:uint64_t
m_timer	tests/catch.hpp	/^  Timer m_timer;$/;"	m	class:Catch::Section	typeref:typename:Timer
m_to	tests/catch.hpp	/^  T m_to;$/;"	m	class:Catch::BetweenGenerator	typeref:typename:T
m_totalSize	tests/catch.hpp	/^  size_t m_totalSize;$/;"	m	class:Catch::CompositeGenerator	typeref:typename:size_t
m_totals	tests/catch.hpp	/^        Totals m_totals;$/;"	m	class:Catch::RunContext	typeref:typename:Totals
m_trackerContext	tests/catch.hpp	/^        TrackerContext m_trackerContext;$/;"	m	class:Catch::RunContext	typeref:typename:TrackerContext
m_translators	tests/catch.hpp	/^        std::vector<const IExceptionTranslator*> m_translators;$/;"	m	class:Catch::ExceptionTranslatorRegistry	typeref:typename:std::vector<const IExceptionTranslator * >
m_underlyingPattern	tests/catch.hpp	/^            Ptr<Pattern> m_underlyingPattern;$/;"	m	class:Catch::TestSpec::ExcludedPattern	typeref:typename:Ptr<Pattern>
m_unfinishedSections	tests/catch.hpp	/^        std::vector<SectionEndInfo> m_unfinishedSections;$/;"	m	class:Catch::RunContext	typeref:typename:std::vector<SectionEndInfo>
m_unnamedCount	tests/catch.hpp	/^        size_t m_unnamedCount;$/;"	m	class:Catch::TestRegistry	typeref:typename:size_t
m_unusedTokens	tests/catch.hpp	/^        std::vector<Clara::Parser::Token> m_unusedTokens;$/;"	m	class:Catch::Session	typeref:typename:std::vector<Clara::Parser::Token>
m_value	tests/catch.hpp	/^  double m_value;$/;"	m	class:Catch::Detail::Approx	typeref:typename:double
m_values	tests/catch.hpp	/^  std::vector <T> m_values;$/;"	m	class:Catch::ValuesGenerator	typeref:typename:std::vector<T>
m_what	tests/catch.hpp	/^  std::string m_what;$/;"	m	class:Catch::NotImplementedException	typeref:typename:std::string
m_wildcard	tests/catch.hpp	/^        WildcardPosition m_wildcard;$/;"	m	class:Catch::WildcardPattern	typeref:typename:WildcardPosition
m_wildcardPattern	tests/catch.hpp	/^            WildcardPattern m_wildcardPattern;$/;"	m	class:Catch::TestSpec::NamePattern	typeref:typename:WildcardPattern
m_writer	tests/catch.hpp	/^            mutable XmlWriter* m_writer;$/;"	m	class:Catch::XmlWriter::ScopedElement	typeref:typename:XmlWriter *
m_writer	tests/catch.hpp	/^        WriterF m_writer;$/;"	m	class:Catch::StreamBufImpl	typeref:typename:WriterF
m_xml	tests/catch.hpp	/^        XmlWriter m_xml;$/;"	m	class:Catch::XmlReporter	typeref:typename:XmlWriter
macroName	tests/catch.hpp	/^  std::string macroName;$/;"	m	struct:Catch::AssertionInfo	typeref:typename:std::string
macroName	tests/catch.hpp	/^  std::string macroName;$/;"	m	struct:Catch::MessageInfo	typeref:typename:std::string
main	tests/catch.hpp	/^int main (int argc, char * argv[]) {$/;"	f	typeref:typename:int
main	tests/catch.hpp	/^int main (int argc, char * const argv[]) {$/;"	f	typeref:typename:int
majorVersion	tests/catch.hpp	/^        unsigned int const majorVersion;$/;"	m	struct:Catch::Version	typeref:typename:unsigned int const
makeCommandLineParser	tests/catch.hpp	/^    inline Clara::CommandLine<ConfigData> makeCommandLineParser() {$/;"	f	namespace:Catch	typeref:typename:Clara::CommandLine<ConfigData>
makeRatio	tests/catch.hpp	/^        static std::size_t makeRatio( std::size_t number, std::size_t total ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:std::size_t
makeReporter	tests/catch.hpp	/^    Ptr<IStreamingReporter> makeReporter( Ptr<Config> const& config ) {$/;"	f	namespace:Catch	typeref:typename:Ptr<IStreamingReporter>
makeSafe	tests/catch.hpp	/^  static type makeSafe(bool value) {$/;"	f	class:Catch::SafeBool	typeref:typename:type
makeString	tests/catch.hpp	/^inline std::string makeString(const char *str) { return str ? std::string(str) : std::string(); /;"	f	namespace:Catch::Matchers::Impl::StdString	typeref:typename:std::string
makeString	tests/catch.hpp	/^inline std::string makeString(std::string const &str) { return str; }$/;"	f	namespace:Catch::Matchers::Impl::StdString	typeref:typename:std::string
makeString	tests/catch.hpp	/^std::string makeString(T const &value) {$/;"	f	namespace:Catch::Detail	typeref:typename:std::string
makeTestCase	tests/catch.hpp	/^    TestCase makeTestCase(  ITestCase* _testCase,$/;"	f	namespace:Catch	typeref:typename:TestCase
makeUnexpectedResultBuilder	tests/catch.hpp	/^        ResultBuilder makeUnexpectedResultBuilder() const {$/;"	f	class:Catch::RunContext	typeref:typename:ResultBuilder
markAsNeedingAnotherRun	tests/catch.hpp	/^        virtual void markAsNeedingAnotherRun() CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:void
match	tests/catch.hpp	/^                virtual bool match( ExpressionType const& str ) const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::Contains	typeref:typename:bool
match	tests/catch.hpp	/^                virtual bool match( ExpressionType const& str ) const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::EndsWith	typeref:typename:bool
match	tests/catch.hpp	/^                virtual bool match( ExpressionType const& str ) const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::Equals	typeref:typename:bool
match	tests/catch.hpp	/^                virtual bool match( ExpressionType const& str ) const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::StartsWith	typeref:typename:bool
match	tests/catch.hpp	/^  virtual bool match(ExpressionT const &expr) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	typeref:typename:bool
match	tests/catch.hpp	/^  virtual bool match(ExpressionT const &expr) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	typeref:typename:bool
match	tests/catch.hpp	/^  virtual bool match(std::string const &expr) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	typeref:typename:bool
match	tests/catch.hpp	/^  virtual bool match(std::string const &expr) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	typeref:typename:bool
match	tests/catch.hpp	/^  virtual bool match(std::string const &expr) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	typeref:typename:bool
match	tests/catch.hpp	/^  virtual bool match(std::string const &expr) const {$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	typeref:typename:bool
matchTest	tests/catch.hpp	/^    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) /;"	f	namespace:Catch	typeref:typename:bool
matches	tests/catch.hpp	/^            bool matches( TestCaseInfo const& testCase ) const {$/;"	f	struct:Catch::TestSpec::Filter	typeref:typename:bool
matches	tests/catch.hpp	/^            virtual bool matches( TestCaseInfo const& testCase ) const { return !m_underlyingPat/;"	f	class:Catch::TestSpec::ExcludedPattern	typeref:typename:bool
matches	tests/catch.hpp	/^            virtual bool matches( TestCaseInfo const& testCase ) const {$/;"	f	class:Catch::TestSpec::NamePattern	typeref:typename:bool
matches	tests/catch.hpp	/^            virtual bool matches( TestCaseInfo const& testCase ) const {$/;"	f	class:Catch::TestSpec::TagPattern	typeref:typename:bool
matches	tests/catch.hpp	/^        bool matches( TestCaseInfo const& testCase ) const {$/;"	f	class:Catch::TestSpec	typeref:typename:bool
matches	tests/catch.hpp	/^        virtual bool matches( std::string const& str ) const {$/;"	f	class:Catch::WildcardPattern	typeref:typename:bool
member	tests/catch.hpp	/^            M C::* member;$/;"	m	struct:Clara::Detail::BoundDataMember	typeref:typename:M C::*
message	tests/catch.hpp	/^            std::string message;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:std::string
message	tests/catch.hpp	/^  std::string message;$/;"	m	struct:Catch::AssertionResultData	typeref:typename:std::string
message	tests/catch.hpp	/^  std::string message;$/;"	m	struct:Catch::MessageInfo	typeref:typename:std::string
messageLabel	tests/catch.hpp	/^            std::string messageLabel;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:std::string
messages	tests/catch.hpp	/^            std::vector<MessageInfo> messages;$/;"	m	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:std::vector<MessageInfo>
messages	tests/catch.hpp	/^            std::vector<MessageInfo> messages;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:std::vector<MessageInfo>
minorVersion	tests/catch.hpp	/^        unsigned int const minorVersion;$/;"	m	struct:Catch::Version	typeref:typename:unsigned int const
missingAssertions	tests/catch.hpp	/^        bool missingAssertions;$/;"	m	struct:Catch::SectionStats	typeref:typename:bool
mode	file.h	/^    int mode;$/;"	m	class:File	typeref:typename:int
mode	tests/catch.hpp	/^        Mode mode;$/;"	m	class:Clara::Parser	typeref:typename:Mode
move	tests/catch.hpp	/^  void move(CompositeGenerator &other) {$/;"	f	class:Catch::CompositeGenerator	typeref:typename:void
moveNext	tests/catch.hpp	/^        bool moveNext() {$/;"	f	class:Catch::GeneratorsForTest	typeref:typename:bool
moveNext	tests/catch.hpp	/^        bool moveNext() {$/;"	f	struct:Catch::GeneratorInfo	typeref:typename:bool
moveNext	tests/catch.hpp	/^        void moveNext() {$/;"	f	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:void
moveToParent	tests/catch.hpp	/^        void moveToParent() {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:void
moveToThis	tests/catch.hpp	/^        void moveToThis() {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:void
name	tests/catch.hpp	/^        std::string name;$/;"	m	struct:Catch::ConfigData	typeref:typename:std::string
name	tests/catch.hpp	/^        std::string name;$/;"	m	struct:Catch::GroupInfo	typeref:typename:std::string
name	tests/catch.hpp	/^        std::string name;$/;"	m	struct:Catch::TestRunInfo	typeref:typename:std::string
name	tests/catch.hpp	/^        virtual std::string name() const        { return m_data.name.empty() ? m_data.processNam/;"	f	class:Catch::Config	typeref:typename:std::string
name	tests/catch.hpp	/^    struct SignalDefs { int id; const char* name; };$/;"	m	struct:Catch::SignalDefs	typeref:typename:const char *
name	tests/catch.hpp	/^  const char *name;$/;"	m	struct:Catch::NameAndDesc	typeref:typename:const char *
name	tests/catch.hpp	/^  std::string name;$/;"	m	struct:Catch::SectionInfo	typeref:typename:std::string
name	tests/catch.hpp	/^  std::string name;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:std::string
newlineIfNecessary	tests/catch.hpp	/^        void newlineIfNecessary() {$/;"	f	class:Catch::XmlWriter	typeref:typename:void
noMatchingTestCases	tests/catch.hpp	/^        virtual void noMatchingTestCases( std::string const& ) CATCH_OVERRIDE {}$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
noMatchingTestCases	tests/catch.hpp	/^        virtual void noMatchingTestCases( std::string const& \/*spec*\/ ) CATCH_OVERRIDE {}$/;"	f	class:Catch::JunitReporter	typeref:typename:void
noMatchingTestCases	tests/catch.hpp	/^        virtual void noMatchingTestCases( std::string const& s ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
noMatchingTestCases	tests/catch.hpp	/^        virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
noMatchingTestCases	tests/catch.hpp	/^        virtual void noMatchingTestCases( std::string const& spec ) {$/;"	f	struct:Catch::CompactReporter	typeref:typename:void
noMatchingTestCases	tests/catch.hpp	/^    void LegacyReporterAdapter::noMatchingTestCases( std::string const& ) {}$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
noThrow	tests/catch.hpp	/^        bool noThrow;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
none	tests/catch.hpp	/^  bool none() const { return nullableValue == CATCH_NULL; }$/;"	f	class:Catch::Option	typeref:typename:bool
nullableValue	tests/catch.hpp	/^  T *nullableValue;$/;"	m	class:Catch::Option	typeref:typename:T *
okToFail	tests/catch.hpp	/^    bool TestCaseInfo::okToFail() const {$/;"	f	class:Catch::TestCaseInfo	typeref:typename:bool
op	tests/catch.hpp	/^    std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	typeref:typename:std::string
opCast	tests/catch.hpp	/^inline T &opCast(T const &t) { return const_cast<T &>(t); }$/;"	f	namespace:Catch::Internal	typeref:typename:T &
opCast	tests/catch.hpp	/^inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }$/;"	f	namespace:Catch::Internal	typeref:typename:std::nullptr_t
openChild	tests/catch.hpp	/^        virtual void openChild() CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:void
openStream	tests/catch.hpp	/^        IStream const* openStream() {$/;"	f	class:Catch::Config	typeref:typename:IStream const *
open_status	tests/ReadTests.cpp	/^        File::STATUS open_status = f.Open(file_path);$/;"	v	typeref:typename:File::STATUS
open_status	tests/TestInterface.cpp	/^        File::STATUS open_status = f.Open(file_path);$/;"	v	typeref:typename:File::STATUS
operator !	tests/catch.hpp	/^  bool operator!() const { return m_p == CATCH_NULL; }$/;"	f	class:Catch::Ptr	typeref:typename:bool
operator !	tests/catch.hpp	/^  bool operator!() const { return nullableValue == CATCH_NULL; }$/;"	f	class:Catch::Option	typeref:typename:bool
operator !	tests/catch.hpp	/^Generic::Not<ExpressionT> Matcher<ExpressionT>::operator!() const {$/;"	f	class:Catch::Matchers::Impl::Matcher	typeref:typename:Generic::Not<ExpressionT>
operator !=	tests/catch.hpp	/^  ResultBuilder &operator!=(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator !=	tests/catch.hpp	/^  ResultBuilder &operator!=(bool rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator !=	tests/catch.hpp	/^  friend bool operator!=(Approx const &lhs, double rhs) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:bool
operator !=	tests/catch.hpp	/^  friend bool operator!=(double lhs, Approx const &rhs) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:bool
operator &&	tests/catch.hpp	/^  AllOf operator&&(Matcher<ExpressionT> const &other) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	typeref:typename:AllOf
operator &&	tests/catch.hpp	/^Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator&&(Matcher<ExpressionT> const &other) /;"	f	class:Catch::Matchers::Impl::Matcher	typeref:typename:Generic::AllOf<ExpressionT>
operator ()	tests/catch.hpp	/^            bool operator ()( Ptr<ITracker> const& tracker ) {$/;"	f	class:Catch::TestCaseTracking::TrackerBase::TrackerHasName	typeref:typename:bool
operator ()	tests/catch.hpp	/^        int operator()( int n ) const { return std::rand() % n; }$/;"	f	struct:Catch::RandomNumberGenerator	typeref:typename:int
operator ()	tests/catch.hpp	/^        void operator()( std::string const&str ) {$/;"	f	struct:Catch::OutputDebugWriter	typeref:typename:void
operator ()	tests/catch.hpp	/^  Approx operator()(double value) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:Approx
operator () 	tests/catch.hpp	/^            bool operator() ( Ptr<SectionNode> const& node ) const {$/;"	f	struct:Catch::CumulativeReporterBase::BySectionInfo	typeref:typename:bool
operator () 	tests/catch.hpp	/^        bool operator() (TestCase i,TestCase j) const { return (i<j);}$/;"	f	struct:Catch::LexSort	typeref:typename:bool
operator *	tests/catch.hpp	/^  T &operator*() const { return *m_p; }$/;"	f	class:Catch::Ptr	typeref:typename:T &
operator *	tests/catch.hpp	/^  T &operator*() { return *nullableValue; }$/;"	f	class:Catch::Option	typeref:typename:T &
operator *	tests/catch.hpp	/^  T const &operator*() const { return *nullableValue; }$/;"	f	class:Catch::Option	typeref:typename:T const &
operator +	tests/catch.hpp	/^  std::string operator+() {$/;"	f	struct:Catch::StreamEndStop	typeref:typename:std::string
operator +	tests/catch.hpp	/^T const &operator+(T const &value, StreamEndStop) {$/;"	f	namespace:Catch	typeref:typename:T const &
operator +=	tests/catch.hpp	/^  Counts &operator+=(Counts const &other) {$/;"	f	struct:Catch::Counts	typeref:typename:Counts &
operator +=	tests/catch.hpp	/^  Totals &operator+=(Totals const &other) {$/;"	f	struct:Catch::Totals	typeref:typename:Totals &
operator -	tests/catch.hpp	/^  Counts operator-(Counts const &other) const {$/;"	f	struct:Catch::Counts	typeref:typename:Counts
operator -	tests/catch.hpp	/^  Totals operator-(Totals const &other) const {$/;"	f	struct:Catch::Totals	typeref:typename:Totals
operator ->	tests/catch.hpp	/^  T *operator->() const { return m_p; }$/;"	f	class:Catch::Ptr	typeref:typename:T *
operator ->	tests/catch.hpp	/^  T *operator->() { return nullableValue; }$/;"	f	class:Catch::Option	typeref:typename:T *
operator ->	tests/catch.hpp	/^  const T *operator->() const { return nullableValue; }$/;"	f	class:Catch::Option	typeref:typename:const T *
operator <	tests/catch.hpp	/^    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const {$/;"	f	class:Catch::SourceLineInfo	typeref:typename:bool
operator <	tests/catch.hpp	/^    bool TestCase::operator < ( TestCase const& other ) const {$/;"	f	class:Catch::TestCase	typeref:typename:bool
operator <	tests/catch.hpp	/^  ResultBuilder &operator<(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator <	tests/catch.hpp	/^  bool operator<(MessageInfo const &other) const {$/;"	f	struct:Catch::MessageInfo	typeref:typename:bool
operator <<	tests/catch.hpp	/^        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {$/;"	f	class:Catch::XmlEncode	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^    inline std::ostream& operator << ( std::ostream& os, Colour const& ) { return os; }$/;"	f	namespace:Catch	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {$/;"	f	namespace:Catch	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^    std::ostream& operator << ( std::ostream& os, Version const& version ) {$/;"	f	namespace:Catch	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {$/;"	f	namespace:Catch	typeref:typename:std::ostream &
operator <<	tests/catch.hpp	/^  MessageBuilder &operator<<(T const &value) {$/;"	f	struct:Catch::MessageBuilder	typeref:typename:MessageBuilder &
operator <<	tests/catch.hpp	/^  ResultBuilder &operator<<(T const &value) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ResultBuilder &
operator <=	tests/catch.hpp	/^  ResultBuilder &operator<=(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator <=	tests/catch.hpp	/^inline ExpressionLhs<T const &> ResultBuilder::operator<=(T const &operand) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ExpressionLhs<T const &>
operator <=	tests/catch.hpp	/^inline ExpressionLhs<bool> ResultBuilder::operator<=(bool value) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ExpressionLhs<bool>
operator =	tests/catch.hpp	/^            BoundArgFunction& operator = ( BoundArgFunction const& other ) {$/;"	f	class:Clara::Detail::BoundArgFunction	typeref:typename:BoundArgFunction &
operator =	tests/catch.hpp	/^        LazyStat& operator=( T const& _value ) {$/;"	f	struct:Catch::LazyStat	typeref:typename:LazyStat &
operator =	tests/catch.hpp	/^    TestCase& TestCase::operator = ( TestCase const& other ) {$/;"	f	class:Catch::TestCase	typeref:typename:TestCase &
operator =	tests/catch.hpp	/^  CopyableStream &operator=(CopyableStream const &other) {$/;"	f	struct:Catch::CopyableStream	typeref:typename:CopyableStream &
operator =	tests/catch.hpp	/^  Option &operator=(Option const &_other) {$/;"	f	class:Catch::Option	typeref:typename:Option &
operator =	tests/catch.hpp	/^  Option &operator=(T const &_value) {$/;"	f	class:Catch::Option	typeref:typename:Option &
operator =	tests/catch.hpp	/^  Ptr &operator=(Ptr const &other) {$/;"	f	class:Catch::Ptr	typeref:typename:Ptr &
operator =	tests/catch.hpp	/^  Ptr &operator=(T *p) {$/;"	f	class:Catch::Ptr	typeref:typename:Ptr &
operator ==	tests/catch.hpp	/^            bool operator == ( Ptr<SectionNode> const& other ) const {$/;"	f	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:bool
operator ==	tests/catch.hpp	/^            bool operator == ( SectionNode const& other ) const {$/;"	f	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:bool
operator ==	tests/catch.hpp	/^    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const {$/;"	f	class:Catch::SourceLineInfo	typeref:typename:bool
operator ==	tests/catch.hpp	/^    bool TestCase::operator == ( TestCase const& other ) const {$/;"	f	class:Catch::TestCase	typeref:typename:bool
operator ==	tests/catch.hpp	/^  ResultBuilder &operator==(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator ==	tests/catch.hpp	/^  ResultBuilder &operator==(bool rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator ==	tests/catch.hpp	/^  bool operator==(MessageInfo const &other) const {$/;"	f	struct:Catch::MessageInfo	typeref:typename:bool
operator ==	tests/catch.hpp	/^  friend bool operator==(Approx const &lhs, double rhs) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:bool
operator ==	tests/catch.hpp	/^  friend bool operator==(double lhs, Approx const &rhs) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:bool
operator >	tests/catch.hpp	/^  ResultBuilder &operator>(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator >=	tests/catch.hpp	/^  ResultBuilder &operator>=(RhsT const &rhs) {$/;"	f	class:Catch::ExpressionLhs	typeref:typename:ResultBuilder &
operator []	tests/catch.hpp	/^            OptBuilder& operator[]( std::string const& optName ) {$/;"	f	class:Clara::CommandLine::OptBuilder	typeref:typename:OptBuilder &
operator []	tests/catch.hpp	/^        ArgBuilder operator[]( UnpositionalTag ) {$/;"	f	class:Clara::CommandLine	typeref:typename:ArgBuilder
operator []	tests/catch.hpp	/^        ArgBuilder operator[]( int position ) {$/;"	f	class:Clara::CommandLine	typeref:typename:ArgBuilder
operator []	tests/catch.hpp	/^        OptBuilder operator[]( std::string const& optName ) {$/;"	f	class:Clara::CommandLine	typeref:typename:OptBuilder
operator []	tests/catch.hpp	/^        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string const &
operator []	tests/catch.hpp	/^        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string const &
operator |	tests/catch.hpp	/^inline ResultDisposition::Flags operator|(ResultDisposition::Flags lhs, ResultDisposition::Flags/;"	f	namespace:Catch	typeref:typename:ResultDisposition::Flags
operator ||	tests/catch.hpp	/^  AnyOf operator||(Matcher<ExpressionT> const &other) const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	typeref:typename:AnyOf
operator ||	tests/catch.hpp	/^Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator||(Matcher<ExpressionT> const &other) /;"	f	class:Catch::Matchers::Impl::Matcher	typeref:typename:Generic::AnyOf<ExpressionT>
optUsage	tests/catch.hpp	/^        std::string optUsage() const {$/;"	f	class:Clara::CommandLine	typeref:typename:std::string
optUsage	tests/catch.hpp	/^        void optUsage( std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::con/;"	f	class:Clara::CommandLine	typeref:typename:void
optimum_blocksize	tests/ReadTests.cpp	/^        blksize_t optimum_blocksize = fs.st_blksize;$/;"	v	typeref:typename:blksize_t
optimum_blocksize	tests/TestInterface.cpp	/^        blksize_t optimum_blocksize = fs.st_blksize;$/;"	v	typeref:typename:blksize_t
originalBackgroundAttributes	tests/catch.hpp	/^        WORD originalBackgroundAttributes;$/;"	m	class:Catch::__anond33fe2000510::Win32ColourImpl	typeref:typename:WORD
originalForegroundAttributes	tests/catch.hpp	/^        WORD originalForegroundAttributes;$/;"	m	class:Catch::__anond33fe2000510::Win32ColourImpl	typeref:typename:WORD
oss	tests/catch.hpp	/^  std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream	typeref:typename:std::ostringstream
outputFilename	tests/catch.hpp	/^        std::string outputFilename;$/;"	m	struct:Catch::ConfigData	typeref:typename:std::string
overallIndex	tests/catch.hpp	/^    size_t overallIndex = getCurrentContext().getGeneratorIndex(m_fileInfo, m_totalSize);$/;"	m	class:Catch::CompositeGenerator	typeref:typename:size_t
overflow	tests/catch.hpp	/^        int overflow( int c ) {$/;"	f	class:Catch::StreamBufImpl	typeref:typename:int
parent	tests/catch.hpp	/^        virtual ITracker& parent() CATCH_OVERRIDE {$/;"	f	class:Catch::TestCaseTracking::TrackerBase	typeref:typename:ITracker &
parse	tests/catch.hpp	/^        ConfigT parse( std::vector<std::string> const& args ) const {$/;"	f	class:Clara::CommandLine	typeref:typename:ConfigT
parse	tests/catch.hpp	/^        TestSpecParser& parse( std::string const& arg ) {$/;"	f	class:Catch::TestSpecParser	typeref:typename:TestSpecParser &
parseInto	tests/catch.hpp	/^        std::vector<Parser::Token> parseInto( std::vector<std::string> const& args, ConfigT& con/;"	f	class:Clara::CommandLine	typeref:typename:std::vector<Parser::Token>
parseIntoTokens	tests/catch.hpp	/^        void parseIntoTokens( std::string const& arg, std::vector<Token>& tokens ) {$/;"	f	class:Clara::Parser	typeref:typename:void
parseIntoTokens	tests/catch.hpp	/^        void parseIntoTokens( std::vector<std::string> const& args, std::vector<Token>& tokens )/;"	f	class:Clara::Parser	typeref:typename:void
parseSpecialTag	tests/catch.hpp	/^    inline TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {$/;"	f	namespace:Catch	typeref:typename:TestCaseInfo::SpecialProperties
parseTestSpec	tests/catch.hpp	/^    inline TestSpec parseTestSpec( std::string const& arg ) {$/;"	f	namespace:Catch	typeref:typename:TestSpec
passOrFail	tests/catch.hpp	/^            std::string passOrFail;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:std::string
passed	tests/catch.hpp	/^  std::size_t passed;$/;"	m	struct:Catch::Counts	typeref:typename:std::size_t
passedString	tests/catch.hpp	/^            static const char* passedString() { return "PASSED"; }$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:const char *
passedString	tests/catch.hpp	/^            static const char* passedString() { return "passed"; }$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:const char *
patchNumber	tests/catch.hpp	/^        unsigned int const patchNumber;$/;"	m	struct:Catch::Version	typeref:typename:unsigned int const
performOptionalSelector	tests/catch.hpp	/^inline id performOptionalSelector( id obj, SEL sel ) {$/;"	f	typeref:typename:id
placeholder	tests/catch.hpp	/^        std::string placeholder; \/\/ Only value if boundField takes an arg$/;"	m	struct:Clara::CommonArgProperties	typeref:typename:std::string
platformColourInstance	tests/catch.hpp	/^    IColourImpl* platformColourInstance() {$/;"	f	namespace:Catch::__anond33fe2000510	typeref:typename:IColourImpl *
platformColourInstance	tests/catch.hpp	/^    IColourImpl* platformColourInstance() {$/;"	f	namespace:Catch::__anond33fe2000610	typeref:typename:IColourImpl *
platformColourInstance	tests/catch.hpp	/^    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }$/;"	f	namespace:Catch	typeref:typename:IColourImpl *
pluralise	tests/catch.hpp	/^    pluralise::pluralise( std::size_t count, std::string const& label )$/;"	f	class:Catch::pluralise
pluralise	tests/catch.hpp	/^struct pluralise {$/;"	s	namespace:Catch
popScopedMessage	tests/catch.hpp	/^        virtual void popScopedMessage( MessageInfo const& message ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
populate	tests/catch.hpp	/^        std::vector<Parser::Token> populate( std::vector<Parser::Token> const& tokens, ConfigT& /;"	f	class:Clara::CommandLine	typeref:typename:std::vector<Parser::Token>
populateFixedArgs	tests/catch.hpp	/^        std::vector<Parser::Token> populateFixedArgs( std::vector<Parser::Token> const& tokens, /;"	f	class:Clara::CommandLine	typeref:typename:std::vector<Parser::Token>
populateFloatingArgs	tests/catch.hpp	/^        std::vector<Parser::Token> populateFloatingArgs( std::vector<Parser::Token> const& token/;"	f	class:Clara::CommandLine	typeref:typename:std::vector<Parser::Token>
populateOptions	tests/catch.hpp	/^        std::vector<Parser::Token> populateOptions( std::vector<Parser::Token> const& tokens, Co/;"	f	class:Clara::CommandLine	typeref:typename:std::vector<Parser::Token>
position	tests/catch.hpp	/^        int position; \/\/ -1 means non-positional (floating)$/;"	m	struct:Clara::PositionalArgProperties	typeref:typename:int
prevAssertions	tests/catch.hpp	/^  Counts prevAssertions;$/;"	m	struct:Catch::SectionEndInfo	typeref:typename:Counts
print	tests/catch.hpp	/^            void print() const {$/;"	f	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:void
print	tests/catch.hpp	/^            void print() {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
print	tests/catch.hpp	/^      static void print( const Tuple& tuple, std::ostream& os )$/;"	f	struct:Catch::TupleDetail::ElementPrinter	typeref:typename:void
print	tests/catch.hpp	/^      static void print( const Tuple&, std::ostream& ) {}$/;"	f	struct:Catch::TupleDetail::ElementPrinter	typeref:typename:void
printClosedHeader	tests/catch.hpp	/^        void printClosedHeader( std::string const& _name ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printExpressionWas	tests/catch.hpp	/^            void printExpressionWas() {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printHeaderString	tests/catch.hpp	/^        void printHeaderString( std::string const& _string, std::size_t indent = 0 ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printInfoMessages	tests/catch.hpp	/^            bool printInfoMessages;$/;"	m	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:bool
printInfoMessages	tests/catch.hpp	/^            bool printInfoMessages;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:bool
printIssue	tests/catch.hpp	/^            void printIssue( std::string issue ) const {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printMessage	tests/catch.hpp	/^            void printMessage() const {$/;"	f	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:void
printMessage	tests/catch.hpp	/^            void printMessage() {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printOpenHeader	tests/catch.hpp	/^        void printOpenHeader( std::string const& _name ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printOriginalExpression	tests/catch.hpp	/^            void printOriginalExpression() const {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printOriginalExpression	tests/catch.hpp	/^            void printOriginalExpression() const {$/;"	f	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:void
printReconstructedExpression	tests/catch.hpp	/^            void printReconstructedExpression() const {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printReconstructedExpression	tests/catch.hpp	/^            void printReconstructedExpression() const {$/;"	f	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:void
printRemainingMessages	tests/catch.hpp	/^            void printRemainingMessages( Colour::Code colour = dimColour() ) {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printResultType	tests/catch.hpp	/^            void printResultType( Colour::Code colour, std::string passOrFail ) const {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printResultType	tests/catch.hpp	/^            void printResultType() const {$/;"	f	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:void
printSourceInfo	tests/catch.hpp	/^            void printSourceInfo() const {$/;"	f	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:void
printSourceInfo	tests/catch.hpp	/^            void printSourceInfo() const {$/;"	f	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:void
printSummaryDivider	tests/catch.hpp	/^        void printSummaryDivider() {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printSummaryRow	tests/catch.hpp	/^        void printSummaryRow( std::string const& label, std::vector<SummaryColumn> const& cols, /;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printTestCaseAndSectionHeader	tests/catch.hpp	/^        void printTestCaseAndSectionHeader() {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printTotals	tests/catch.hpp	/^        void printTotals( Totals const& totals ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
printTotals	tests/catch.hpp	/^        void printTotals( const Totals& totals ) const {$/;"	f	struct:Catch::CompactReporter	typeref:typename:void
printTotalsDivider	tests/catch.hpp	/^        void printTotalsDivider( Totals const& totals ) {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
processName	tests/catch.hpp	/^        std::string processName;$/;"	m	struct:Catch::ConfigData	typeref:typename:std::string
properties	tests/catch.hpp	/^  SpecialProperties properties;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:SpecialProperties
pushScopedMessage	tests/catch.hpp	/^        virtual void pushScopedMessage( MessageInfo const& message ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
rangeToString	tests/catch.hpp	/^std::string rangeToString(InputIterator first, InputIterator last) {$/;"	f	namespace:Catch::Detail	typeref:typename:std::string
rawMemoryToString	tests/catch.hpp	/^    std::string rawMemoryToString( const void *object, std::size_t size )$/;"	f	namespace:Catch::Detail	typeref:typename:std::string
rawMemoryToString	tests/catch.hpp	/^inline std::string rawMemoryToString(const T &object) {$/;"	f	namespace:Catch::Detail	typeref:typename:std::string
react	tests/catch.hpp	/^    void ResultBuilder::react() {$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
read_size	tests/ReadTests.cpp	/^        int read_size = 15;$/;"	v	typeref:typename:int
read_size	tests/TestInterface.cpp	/^        int read_size = 15;$/;"	v	typeref:typename:int
reconstructExpression	tests/catch.hpp	/^    std::string ResultBuilder::reconstructExpression() const {$/;"	f	class:Catch::ResultBuilder	typeref:typename:std::string
reconstructedExpression	tests/catch.hpp	/^  std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData	typeref:typename:std::string
registerListener	tests/catch.hpp	/^            virtual void registerListener( Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE/;"	f	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:void
registerListener	tests/catch.hpp	/^        void registerListener( Ptr<IReporterFactory> const& factory ) {$/;"	f	class:Catch::ReporterRegistry	typeref:typename:void
registerReporter	tests/catch.hpp	/^            virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const&/;"	f	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:void
registerTest	tests/catch.hpp	/^            virtual void registerTest( TestCase const& testInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:void
registerTest	tests/catch.hpp	/^        virtual void registerTest( TestCase const& testCase ) {$/;"	f	class:Catch::TestRegistry	typeref:typename:void
registerTestCase	tests/catch.hpp	/^    void registerTestCase$/;"	f	namespace:Catch	typeref:typename:void
registerTestCaseFunction	tests/catch.hpp	/^    void registerTestCaseFunction$/;"	f	namespace:Catch	typeref:typename:void
registerTestMethods	tests/catch.hpp	/^    inline size_t registerTestMethods() {$/;"	f	namespace:Catch	typeref:typename:size_t
registerTranslator	tests/catch.hpp	/^            virtual void registerTranslator( const IExceptionTranslator* translator ) CATCH_OVER/;"	f	class:Catch::__anond33fe2000210::RegistryHub	typeref:typename:void
registerTranslator	tests/catch.hpp	/^        virtual void registerTranslator( const IExceptionTranslator* translator ) {$/;"	f	class:Catch::ExceptionTranslatorRegistry	typeref:typename:void
release	tests/catch.hpp	/^  virtual void release() const {$/;"	f	struct:Catch::SharedImpl	typeref:typename:void
replaceInPlace	tests/catch.hpp	/^    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& wi/;"	f	namespace:Catch	typeref:typename:bool
reporterNames	tests/catch.hpp	/^        std::vector<std::string> reporterNames;$/;"	m	struct:Catch::ConfigData	typeref:typename:std::vector<std::string>
reset	tests/catch.hpp	/^		void reset() {}$/;"	f	struct:Catch::FatalConditionHandler	typeref:typename:void
reset	tests/catch.hpp	/^        void reset() {$/;"	f	struct:Catch::FatalConditionHandler	typeref:typename:void
reset	tests/catch.hpp	/^        void reset() {$/;"	f	struct:Catch::LazyStat	typeref:typename:void
reset	tests/catch.hpp	/^  void reset() {$/;"	f	class:Catch::Option	typeref:typename:void
reset	tests/catch.hpp	/^  void reset() {$/;"	f	class:Catch::Ptr	typeref:typename:void
result	tests/catch.hpp	/^            AssertionResult const& result;$/;"	m	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:AssertionResult const &
result	tests/catch.hpp	/^            AssertionResult const& result;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:AssertionResult const &
resultDisposition	tests/catch.hpp	/^  ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo	typeref:typename:ResultDisposition::Flags
resultType	tests/catch.hpp	/^  ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData	typeref:typename:ResultWas::OfType
rhs	tests/catch.hpp	/^    std::string lhs, rhs, op;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	typeref:typename:std::string
rngSeed	tests/catch.hpp	/^        unsigned int rngSeed;$/;"	m	struct:Catch::ConfigData	typeref:typename:unsigned int
rngSeed	tests/catch.hpp	/^        virtual unsigned int rngSeed() const    { return m_data.rngSeed; }$/;"	f	class:Catch::Config	typeref:typename:unsigned int
rngSeed	tests/catch.hpp	/^    unsigned int rngSeed() {$/;"	f	namespace:Catch	typeref:typename:unsigned int
rows	tests/catch.hpp	/^            std::vector<std::string> rows;$/;"	m	struct:Catch::ConsoleReporter::SummaryColumn	typeref:typename:std::vector<std::string>
run	tests/catch.hpp	/^        int run( int argc, char const* const* const argv ) {$/;"	f	class:Catch::Session	typeref:typename:int
run	tests/catch.hpp	/^        int run() {$/;"	f	class:Catch::Session	typeref:typename:int
runCurrentTest	tests/catch.hpp	/^        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
runInfo	tests/catch.hpp	/^        TestRunInfo runInfo;$/;"	m	struct:Catch::TestRunStats	typeref:typename:TestRunInfo
runOrder	tests/catch.hpp	/^        RunTests::InWhatOrder runOrder;$/;"	m	struct:Catch::ConfigData	typeref:typename:RunTests::InWhatOrder
runOrder	tests/catch.hpp	/^        virtual RunTests::InWhatOrder runOrder() const  { return m_data.runOrder; }$/;"	f	class:Catch::Config	typeref:typename:RunTests::InWhatOrder
runTest	tests/catch.hpp	/^        Totals runTest( TestCase const& testCase ) {$/;"	f	class:Catch::RunContext	typeref:typename:Totals
runTests	tests/catch.hpp	/^    Totals runTests( Ptr<Config> const& config ) {$/;"	f	namespace:Catch	typeref:typename:Totals
s	tests/catch.hpp	/^  static std::ostream &s;$/;"	m	struct:Catch::Detail::IsStreamInsertable	typeref:typename:std::ostream &
scale	tests/catch.hpp	/^  Approx &scale(double newScale) {$/;"	f	class:Catch::Detail::Approx	typeref:typename:Approx &
scopedElement	tests/catch.hpp	/^        ScopedElement scopedElement( std::string const& name ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:ScopedElement
section	tests/catch.hpp	/^            SectionTracker* section = CATCH_NULL;$/;"	m	class:Catch::TestCaseTracking::SectionTracker	typeref:typename:SectionTracker *
sectionEnded	tests/catch.hpp	/^        virtual void sectionEnded( SectionEndInfo const& endInfo ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
sectionEnded	tests/catch.hpp	/^        virtual void sectionEnded( SectionStats const& \/* _sectionStats *\/ ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
sectionEnded	tests/catch.hpp	/^        virtual void sectionEnded( SectionStats const& _sectionStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
sectionEnded	tests/catch.hpp	/^        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
sectionEnded	tests/catch.hpp	/^        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
sectionEnded	tests/catch.hpp	/^    virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
sectionEnded	tests/catch.hpp	/^    void LegacyReporterAdapter::sectionEnded( SectionStats const& sectionStats ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
sectionEndedEarly	tests/catch.hpp	/^        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) {$/;"	f	class:Catch::RunContext	typeref:typename:void
sectionInfo	tests/catch.hpp	/^        SectionInfo sectionInfo;$/;"	m	struct:Catch::SectionStats	typeref:typename:SectionInfo
sectionInfo	tests/catch.hpp	/^  SectionInfo sectionInfo;$/;"	m	struct:Catch::SectionEndInfo	typeref:typename:SectionInfo
sectionStarted	tests/catch.hpp	/^        virtual bool sectionStarted ($/;"	f	class:Catch::RunContext	typeref:typename:bool
sectionStarting	tests/catch.hpp	/^        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
sectionStarting	tests/catch.hpp	/^        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
sectionStarting	tests/catch.hpp	/^        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
sectionStarting	tests/catch.hpp	/^        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
sectionStarting	tests/catch.hpp	/^    virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
sectionStarting	tests/catch.hpp	/^    void LegacyReporterAdapter::sectionStarting( SectionInfo const& sectionInfo ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
seedRng	tests/catch.hpp	/^    void seedRng( IConfig const& config ) {$/;"	f	namespace:Catch	typeref:typename:void
sequence	tests/catch.hpp	/^  unsigned int sequence;$/;"	m	struct:Catch::MessageInfo	typeref:typename:unsigned int
set	tests/catch.hpp	/^            virtual void set( C& obj, std::string const& stringValue ) const {$/;"	f	struct:Clara::Detail::BoundBinaryFunction	typeref:typename:void
set	tests/catch.hpp	/^            virtual void set( C& obj, std::string const& stringValue ) const {$/;"	f	struct:Clara::Detail::BoundUnaryFunction	typeref:typename:void
set	tests/catch.hpp	/^            virtual void set( C& p, std::string const& stringValue ) const {$/;"	f	struct:Clara::Detail::BoundDataMember	typeref:typename:void
set	tests/catch.hpp	/^            virtual void set( C& p, std::string const& stringValue ) const {$/;"	f	struct:Clara::Detail::BoundNullaryMethod	typeref:typename:void
set	tests/catch.hpp	/^            virtual void set( C& p, std::string const& stringValue ) const {$/;"	f	struct:Clara::Detail::BoundUnaryMethod	typeref:typename:void
set	tests/catch.hpp	/^            virtual void set( C&, std::string const& ) const {}$/;"	f	struct:Clara::Detail::NullBinder	typeref:typename:void
set	tests/catch.hpp	/^            void set( ConfigT& config, std::string const& value ) const {$/;"	f	class:Clara::Detail::BoundArgFunction	typeref:typename:void
setColour	tests/catch.hpp	/^        void setColour( const char* _escapeCode ) {$/;"	f	class:Catch::__anond33fe2000610::PosixColourImpl	typeref:typename:void
setConfig	tests/catch.hpp	/^        virtual void setConfig( Ptr<IConfig const> const& config ) {$/;"	f	class:Catch::Context	typeref:typename:void
setCurrentTracker	tests/catch.hpp	/^        void setCurrentTracker( ITracker* tracker ) {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:void
setFileInfo	tests/catch.hpp	/^  CompositeGenerator &setFileInfo(const char *fileInfo) {$/;"	f	class:Catch::CompositeGenerator	typeref:typename:CompositeGenerator &
setIndent	tests/catch.hpp	/^        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this;/;"	f	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setIndent	tests/catch.hpp	/^        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this;/;"	f	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setInitialIndent	tests/catch.hpp	/^        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return/;"	f	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setInitialIndent	tests/catch.hpp	/^        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return/;"	f	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setLhs	tests/catch.hpp	/^    ResultBuilder& ResultBuilder::setLhs( std::string const& lhs ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ResultBuilder &
setOp	tests/catch.hpp	/^    ResultBuilder& ResultBuilder::setOp( std::string const& op ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ResultBuilder &
setOrder	tests/catch.hpp	/^    inline void setOrder( ConfigData& config, std::string const& order ) {$/;"	f	namespace:Catch	typeref:typename:void
setPositionalArg	tests/catch.hpp	/^        friend void setPositionalArg( Arg& arg, int position )$/;"	f	class:Clara::CommandLine	typeref:typename:void
setResultCapture	tests/catch.hpp	/^        virtual void setResultCapture( IResultCapture* resultCapture ) {$/;"	f	class:Catch::Context	typeref:typename:void
setResultType	tests/catch.hpp	/^    ResultBuilder& ResultBuilder::setResultType( ResultWas::OfType result ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ResultBuilder &
setResultType	tests/catch.hpp	/^    ResultBuilder& ResultBuilder::setResultType( bool result ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ResultBuilder &
setRhs	tests/catch.hpp	/^    ResultBuilder& ResultBuilder::setRhs( std::string const& rhs ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:ResultBuilder &
setRngSeed	tests/catch.hpp	/^    inline void setRngSeed( ConfigData& config, std::string const& seed ) {$/;"	f	namespace:Catch	typeref:typename:void
setRunner	tests/catch.hpp	/^        virtual void setRunner( IRunner* runner ) {$/;"	f	class:Catch::Context	typeref:typename:void
setShowDurations	tests/catch.hpp	/^    inline void setShowDurations( ConfigData& config, bool _showDurations ) {$/;"	f	namespace:Catch	typeref:typename:void
setStream	tests/catch.hpp	/^        void setStream( std::ostream& os ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:void
setTabChar	tests/catch.hpp	/^        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this/;"	f	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setTabChar	tests/catch.hpp	/^        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this/;"	f	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setTags	tests/catch.hpp	/^    void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags )$/;"	f	namespace:Catch	typeref:typename:void
setTextAttribute	tests/catch.hpp	/^        void setTextAttribute( WORD _textAttribute ) {$/;"	f	class:Catch::__anond33fe2000510::Win32ColourImpl	typeref:typename:void
setThrowOnUnrecognisedTokens	tests/catch.hpp	/^        CommandLine& setThrowOnUnrecognisedTokens( bool shouldThrow = true ) {$/;"	f	class:Clara::CommandLine	typeref:typename:CommandLine &
setUseColour	tests/catch.hpp	/^    inline void setUseColour( ConfigData& config, std::string const& value ) {$/;"	f	namespace:Catch	typeref:typename:void
setVerbosity	tests/catch.hpp	/^    inline void setVerbosity( ConfigData& config, int level ) {$/;"	f	namespace:Catch	typeref:typename:void
setWidth	tests/catch.hpp	/^        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; /;"	f	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
setWidth	tests/catch.hpp	/^        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; /;"	f	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:TextAttributes &
shortNames	tests/catch.hpp	/^        std::vector<std::string> shortNames;$/;"	m	struct:Clara::OptionArgProperties	typeref:typename:std::vector<std::string>
shouldContinueOnFailure	tests/catch.hpp	/^inline bool shouldContinueOnFailure(int flags) { return (flags & ResultDisposition::ContinueOnFa/;"	f	namespace:Catch	typeref:typename:bool
shouldDebugBreak	tests/catch.hpp	/^        bool shouldDebugBreak() const { return m_data.shouldDebugBreak; }$/;"	f	class:Catch::Config	typeref:typename:bool
shouldDebugBreak	tests/catch.hpp	/^        bool shouldDebugBreak;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
shouldDebugBreak	tests/catch.hpp	/^    bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }$/;"	f	class:Catch::ResultBuilder	typeref:typename:bool
shouldRedirectStdOut	tests/catch.hpp	/^        bool shouldRedirectStdOut;$/;"	m	struct:Catch::ReporterPreferences	typeref:typename:bool
shouldSuppressFailure	tests/catch.hpp	/^inline bool shouldSuppressFailure(int flags) { return (flags & ResultDisposition::SuppressFail) /;"	f	namespace:Catch	typeref:typename:bool
showDurations	tests/catch.hpp	/^        ShowDurations::OrNot showDurations;$/;"	m	struct:Catch::ConfigData	typeref:typename:ShowDurations::OrNot
showDurations	tests/catch.hpp	/^        virtual ShowDurations::OrNot showDurations() const { return m_data.showDurations; }$/;"	f	class:Catch::Config	typeref:typename:ShowDurations::OrNot
showHelp	tests/catch.hpp	/^        bool showHelp() const { return m_data.showHelp; }$/;"	f	class:Catch::Config	typeref:typename:bool
showHelp	tests/catch.hpp	/^        bool showHelp;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
showHelp	tests/catch.hpp	/^        void showHelp( std::string const& processName ) {$/;"	f	class:Catch::Session	typeref:typename:void
showInvisibles	tests/catch.hpp	/^        bool showInvisibles() const { return m_data.showInvisibles; }$/;"	f	class:Catch::Config	typeref:typename:bool
showInvisibles	tests/catch.hpp	/^        bool showInvisibles;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
showSuccessfulTests	tests/catch.hpp	/^        bool showSuccessfulTests;$/;"	m	struct:Catch::ConfigData	typeref:typename:bool
signalDefs	tests/catch.hpp	/^    SignalDefs signalDefs[] = {$/;"	v	namespace:Catch	typeref:typename:SignalDefs[]
size	tests/catch.hpp	/^        std::size_t size() const { return lines.size(); }$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::size_t
size	tests/catch.hpp	/^        std::size_t size() const { return lines.size(); }$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::size_t
size	tests/catch.hpp	/^  virtual std::size_t size() const {$/;"	f	class:Catch::BetweenGenerator	typeref:typename:std::size_t
size	tests/catch.hpp	/^  virtual std::size_t size() const {$/;"	f	class:Catch::ValuesGenerator	typeref:typename:std::size_t
sizer	tests/catch.hpp	/^struct FalseType { char sizer[2]; };$/;"	m	struct:Catch::Detail::FalseType	typeref:typename:char[2]
sizer	tests/catch.hpp	/^struct TrueType { char sizer[1]; };$/;"	m	struct:Catch::Detail::TrueType	typeref:typename:char[1]
skipTest	tests/catch.hpp	/^        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
skipTest	tests/catch.hpp	/^        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {}$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
skipTest	tests/catch.hpp	/^    virtual void skipTest( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
skipTest	tests/catch.hpp	/^    void LegacyReporterAdapter::skipTest( TestCaseInfo const& ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
some	tests/catch.hpp	/^  bool some() const { return nullableValue != CATCH_NULL; }$/;"	f	class:Catch::Option	typeref:typename:bool
sortTests	tests/catch.hpp	/^    inline std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& /;"	f	namespace:Catch	typeref:typename:std::vector<TestCase>
spellings	tests/catch.hpp	/^        std::set<std::string> spellings;$/;"	m	struct:Catch::TagInfo	typeref:typename:std::set<std::string>
spliceLine	tests/catch.hpp	/^        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:void
spliceLine	tests/catch.hpp	/^        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:void
start	tests/catch.hpp	/^    void Timer::start() {$/;"	f	class:Catch::Timer	typeref:typename:void
startCycle	tests/catch.hpp	/^        void startCycle() {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:void
startElement	tests/catch.hpp	/^        XmlWriter& startElement( std::string const& name ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
startNewMode	tests/catch.hpp	/^        void startNewMode( Mode mode, std::size_t start ) {$/;"	f	class:Catch::TestSpecParser	typeref:typename:void
startRun	tests/catch.hpp	/^    inline ITracker& TrackerContext::startRun() {$/;"	f	class:Catch::TestCaseTracking::TrackerContext	typeref:typename:ITracker &
startsWith	tests/catch.hpp	/^        inline bool startsWith( std::string const& str, std::string const& prefix ) {$/;"	f	namespace:Clara::Detail	typeref:typename:bool
startsWith	tests/catch.hpp	/^    bool startsWith( std::string const& s, std::string const& prefix ) {$/;"	f	namespace:Catch	typeref:typename:bool
stats	tests/catch.hpp	/^            AssertionStats const& stats;$/;"	m	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:AssertionStats const &
stats	tests/catch.hpp	/^            AssertionStats const& stats;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:AssertionStats const &
stats	tests/catch.hpp	/^            SectionStats stats;$/;"	m	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:SectionStats
status	tests/FileOpenTests.cpp	/^        File::STATUS status = f.Open(file_path);$/;"	v	typeref:typename:File::STATUS
status	tests/ReadTests.cpp	/^        File::READ_STATUS status = f.Read(); \/\/ Let it read the optimum size.$/;"	v	typeref:typename:File::READ_STATUS
status	tests/ReadTests.cpp	/^        File::READ_STATUS status = f.Read();$/;"	v	typeref:typename:File::READ_STATUS
status	tests/ReadTests.cpp	/^        File::READ_STATUS status = f.Read(read_size);$/;"	v	typeref:typename:File::READ_STATUS
status	tests/TestInterface.cpp	/^        File::READ_STATUS status = f.Read(); \/\/ Let it read the optimum size.$/;"	v	typeref:typename:File::READ_STATUS
status	tests/TestInterface.cpp	/^        File::READ_STATUS status = f.Read();$/;"	v	typeref:typename:File::READ_STATUS
status	tests/TestInterface.cpp	/^        File::READ_STATUS status = f.Read(read_size);$/;"	v	typeref:typename:File::READ_STATUS
status	tests/TestInterface.cpp	/^        File::STATUS status = f.Open(file_path);$/;"	v	typeref:typename:File::STATUS
stdErr	tests/catch.hpp	/^            std::string stdErr;$/;"	m	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:std::string
stdErr	tests/catch.hpp	/^        std::string stdErr;$/;"	m	struct:Catch::TestCaseStats	typeref:typename:std::string
stdErrForSuite	tests/catch.hpp	/^        std::ostringstream stdErrForSuite;$/;"	m	class:Catch::JunitReporter	typeref:typename:std::ostringstream
stdOut	tests/catch.hpp	/^            std::string stdOut;$/;"	m	struct:Catch::CumulativeReporterBase::SectionNode	typeref:typename:std::string
stdOut	tests/catch.hpp	/^        std::string stdOut;$/;"	m	struct:Catch::TestCaseStats	typeref:typename:std::string
stdOutForSuite	tests/catch.hpp	/^        std::ostringstream stdOutForSuite;$/;"	m	class:Catch::JunitReporter	typeref:typename:std::ostringstream
stdoutHandle	tests/catch.hpp	/^        HANDLE stdoutHandle;$/;"	m	class:Catch::__anond33fe2000510::Win32ColourImpl	typeref:typename:HANDLE
storage	tests/catch.hpp	/^  char storage[sizeof(T)];$/;"	m	class:Catch::Option	typeref:typename:char[]
str	tests/catch.hpp	/^        std::string str;$/;"	m	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string
str	tests/catch.hpp	/^        std::string str;$/;"	m	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string
stream	tests/catch.hpp	/^            std::ostream& stream;$/;"	m	class:Catch::CompactReporter::AssertionPrinter	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^            std::ostream& stream;$/;"	m	class:Catch::ConsoleReporter::AssertionPrinter	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^        std::ostream& stream() const    { return *m_stream; }$/;"	f	struct:Catch::ReporterConfig	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^        std::ostream& stream() {$/;"	f	class:Catch::XmlWriter	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^        std::ostream& stream;$/;"	m	struct:Catch::CumulativeReporterBase	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^        std::ostream& stream;$/;"	m	struct:Catch::StreamingReporterBase	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^        virtual std::ostream& stream() const    { return m_stream->stream(); }$/;"	f	class:Catch::Config	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^    std::ostream& CoutStream::stream() const {$/;"	f	class:Catch::CoutStream	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^    std::ostream& DebugOutStream::stream() const {$/;"	f	class:Catch::DebugOutStream	typeref:typename:std::ostream &
stream	tests/catch.hpp	/^    std::ostream& FileStream::stream() const {$/;"	f	class:Catch::FileStream	typeref:typename:std::ostream &
subString	tests/catch.hpp	/^        std::string subString() const { return m_arg.substr( m_start, m_pos - m_start ); }$/;"	f	class:Catch::TestSpecParser	typeref:typename:std::string
succeeded	tests/catch.hpp	/^    bool AssertionResult::succeeded() const {$/;"	f	class:Catch::AssertionResult	typeref:typename:bool
suiteTimer	tests/catch.hpp	/^        Timer suiteTimer;$/;"	m	class:Catch::JunitReporter	typeref:typename:Timer
swap	tests/catch.hpp	/^    void TestCase::swap( TestCase& other ) {$/;"	f	class:Catch::TestCase	typeref:typename:void
swap	tests/catch.hpp	/^  void swap(Ptr &other) { std::swap(m_p, other.m_p); }$/;"	f	class:Catch::Ptr	typeref:typename:void
sync	tests/catch.hpp	/^        int sync() {$/;"	f	class:Catch::StreamBufImpl	typeref:typename:int
t	tests/ReadTests.cpp	/^        std::ifstream t("..\/data\/file");$/;"	v	typeref:typename:std::ifstream
t	tests/catch.hpp	/^  static T const &t;$/;"	m	struct:Catch::Detail::IsStreamInsertable	typeref:typename:T const &
tabChar	tests/catch.hpp	/^        char tabChar;               \/\/ If this char is seen the indent is changed to current p/;"	m	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:char
tabChar	tests/catch.hpp	/^        char tabChar;               \/\/ If this char is seen the indent is changed to current p/;"	m	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:char
tag	tests/catch.hpp	/^  std::string tag;$/;"	m	struct:Catch::TagAlias	typeref:typename:std::string
tags	tests/catch.hpp	/^  std::set <std::string> tags;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:std::set<std::string>
tagsAsString	tests/catch.hpp	/^  std::string tagsAsString;$/;"	m	struct:Catch::TestCaseInfo	typeref:typename:std::string
takesArg	tests/catch.hpp	/^            bool takesArg() const { return functionObj->takesArg(); }$/;"	f	class:Clara::Detail::BoundArgFunction	typeref:typename:bool
takesArg	tests/catch.hpp	/^            virtual bool takesArg() const { return !IsBool<M>::value; }$/;"	f	struct:Clara::Detail::BoundDataMember	typeref:typename:bool
takesArg	tests/catch.hpp	/^            virtual bool takesArg() const { return !IsBool<M>::value; }$/;"	f	struct:Clara::Detail::BoundUnaryMethod	typeref:typename:bool
takesArg	tests/catch.hpp	/^            virtual bool takesArg() const { return !IsBool<T>::value; }$/;"	f	struct:Clara::Detail::BoundBinaryFunction	typeref:typename:bool
takesArg	tests/catch.hpp	/^            virtual bool takesArg() const { return false; }$/;"	f	struct:Clara::Detail::BoundNullaryMethod	typeref:typename:bool
takesArg	tests/catch.hpp	/^            virtual bool takesArg() const { return false; }$/;"	f	struct:Clara::Detail::BoundUnaryFunction	typeref:typename:bool
takesArg	tests/catch.hpp	/^            virtual bool takesArg() const { return true; }$/;"	f	struct:Clara::Detail::NullBinder	typeref:typename:bool
takesArg	tests/catch.hpp	/^        bool takesArg() const {$/;"	f	struct:Clara::CommonArgProperties	typeref:typename:bool
test	tests/catch.hpp	/^  Ptr<ITestCase> test;$/;"	m	class:Catch::TestCase	typeref:typename:Ptr<ITestCase>
testCaseEnded	tests/catch.hpp	/^        virtual void testCaseEnded( TestCaseStats const& \/* _testCaseStats *\/ ) CATCH_OVERRIDE/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
testCaseEnded	tests/catch.hpp	/^        virtual void testCaseEnded( TestCaseStats const& _testCaseStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
testCaseEnded	tests/catch.hpp	/^        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
testCaseEnded	tests/catch.hpp	/^        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
testCaseEnded	tests/catch.hpp	/^        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
testCaseEnded	tests/catch.hpp	/^    virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
testCaseEnded	tests/catch.hpp	/^    void LegacyReporterAdapter::testCaseEnded( TestCaseStats const& testCaseStats ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
testCaseStarting	tests/catch.hpp	/^        virtual void testCaseStarting( TestCaseInfo const& ) CATCH_OVERRIDE {}$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
testCaseStarting	tests/catch.hpp	/^        virtual void testCaseStarting( TestCaseInfo const& _testInfo ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
testCaseStarting	tests/catch.hpp	/^        virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
testCaseStarting	tests/catch.hpp	/^    virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
testCaseStarting	tests/catch.hpp	/^    void LegacyReporterAdapter::testCaseStarting( TestCaseInfo const& testInfo ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
testCases	tests/catch.hpp	/^  Counts testCases;$/;"	m	struct:Catch::Totals	typeref:typename:Counts
testFalse	tests/catch.hpp	/^    bool testFalse;$/;"	m	struct:Catch::ResultBuilder::ExprComponents	typeref:typename:bool
testForMissingAssertions	tests/catch.hpp	/^        bool testForMissingAssertions( Counts& assertions ) {$/;"	f	class:Catch::RunContext	typeref:typename:bool
testGroupEnded	tests/catch.hpp	/^        virtual void testGroupEnded( TestGroupStats const& \/* _testGroupStats *\/ ) CATCH_OVERR/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^        virtual void testGroupEnded( TestGroupStats const& _testGroupStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t grou/;"	f	class:Catch::RunContext	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^    virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
testGroupEnded	tests/catch.hpp	/^    void LegacyReporterAdapter::testGroupEnded( TestGroupStats const& testGroupStats ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^        virtual void testGroupStarting( GroupInfo const& ) CATCH_OVERRIDE {}$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^        virtual void testGroupStarting( GroupInfo const& _groupInfo ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t/;"	f	class:Catch::RunContext	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^    virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
testGroupStarting	tests/catch.hpp	/^    void LegacyReporterAdapter::testGroupStarting( GroupInfo const& groupInfo ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
testInfo	tests/catch.hpp	/^        TestCaseInfo testInfo;$/;"	m	struct:Catch::TestCaseStats	typeref:typename:TestCaseInfo
testRunEnded	tests/catch.hpp	/^        virtual void testRunEnded( TestRunStats const& \/* _testRunStats *\/ ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
testRunEnded	tests/catch.hpp	/^        virtual void testRunEnded( TestRunStats const& _testRunStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::ConsoleReporter	typeref:typename:void
testRunEnded	tests/catch.hpp	/^        virtual void testRunEnded( TestRunStats const& _testRunStats ) {$/;"	f	struct:Catch::CompactReporter	typeref:typename:void
testRunEnded	tests/catch.hpp	/^        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
testRunEnded	tests/catch.hpp	/^        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {$/;"	f	struct:Catch::CumulativeReporterBase	typeref:typename:void
testRunEnded	tests/catch.hpp	/^    virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
testRunEnded	tests/catch.hpp	/^    void LegacyReporterAdapter::testRunEnded( TestRunStats const& testRunStats ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
testRunEndedCumulative	tests/catch.hpp	/^        virtual void testRunEndedCumulative() CATCH_OVERRIDE {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
testRunStarting	tests/catch.hpp	/^        virtual void testRunStarting( TestRunInfo const& _testRunInfo ) CATCH_OVERRIDE {$/;"	f	struct:Catch::StreamingReporterBase	typeref:typename:void
testRunStarting	tests/catch.hpp	/^        virtual void testRunStarting( TestRunInfo const& runInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
testRunStarting	tests/catch.hpp	/^        virtual void testRunStarting( TestRunInfo const& testInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::XmlReporter	typeref:typename:void
testRunStarting	tests/catch.hpp	/^    virtual void testRunStarting( TestRunInfo const& testRunInfo ) CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:void
testRunStarting	tests/catch.hpp	/^    void LegacyReporterAdapter::testRunStarting( TestRunInfo const& ) {$/;"	f	class:Catch::LegacyReporterAdapter	typeref:typename:void
testSpec	tests/catch.hpp	/^        TestSpec const& testSpec() const { return m_testSpec; }$/;"	f	class:Catch::Config	typeref:typename:TestSpec const &
testSpec	tests/catch.hpp	/^        TestSpec testSpec() {$/;"	f	class:Catch::TestSpecParser	typeref:typename:TestSpec
testsOrTags	tests/catch.hpp	/^        std::vector<std::string> testsOrTags;$/;"	m	struct:Catch::ConfigData	typeref:typename:std::vector<std::string>
then	tests/catch.hpp	/^  CompositeGenerator &then(CompositeGenerator &other) {$/;"	f	class:Catch::CompositeGenerator	typeref:typename:CompositeGenerator &
then	tests/catch.hpp	/^  CompositeGenerator &then(T value) {$/;"	f	class:Catch::CompositeGenerator	typeref:typename:CompositeGenerator &
throwLogicError	tests/catch.hpp	/^    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo ) {$/;"	f	namespace:Catch	typeref:typename:void
throws	tests/catch.hpp	/^    bool TestCaseInfo::throws() const {$/;"	f	class:Catch::TestCaseInfo	typeref:typename:bool
toLower	tests/catch.hpp	/^    std::string toLower( std::string const& s ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toLowerInPlace	tests/catch.hpp	/^    void toLowerInPlace( std::string& s ) {$/;"	f	namespace:Catch	typeref:typename:void
toString	tests/catch.hpp	/^                virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::Contains	typeref:typename:std::string
toString	tests/catch.hpp	/^                virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::EndsWith	typeref:typename:std::string
toString	tests/catch.hpp	/^                virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::Equals	typeref:typename:std::string
toString	tests/catch.hpp	/^                virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::NSStringMatchers::StartsWith	typeref:typename:std::string
toString	tests/catch.hpp	/^        std::string toString() const {$/;"	f	class:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string
toString	tests/catch.hpp	/^        std::string toString() const {$/;"	f	class:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::Text	typeref:typename:std::string
toString	tests/catch.hpp	/^    std::string toString( NSObject* const& nsObject ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^    std::string toString( NSString const * const& nsstring ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^  std::string toString() const {$/;"	f	class:Catch::Detail::Approx	typeref:typename:std::string
toString	tests/catch.hpp	/^  virtual std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::Generic::AllOf	typeref:typename:std::string
toString	tests/catch.hpp	/^  virtual std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::Generic::AnyOf	typeref:typename:std::string
toString	tests/catch.hpp	/^  virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Contains	typeref:typename:std::string
toString	tests/catch.hpp	/^  virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::EndsWith	typeref:typename:std::string
toString	tests/catch.hpp	/^  virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::Equals	typeref:typename:std::string
toString	tests/catch.hpp	/^  virtual std::string toString() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::StartsWith	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( bool value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( char value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( char* const value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( const char* const value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( const double value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( const float value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( const wchar_t* const value )$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( int value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( long long value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( signed char value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( std::nullptr_t ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( std::string const& value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( std::wstring const& value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( unsigned char value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( unsigned int value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( unsigned long long value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( unsigned long value ) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString( wchar_t* const value )$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString(T const &value) {$/;"	f	namespace:Catch	typeref:typename:std::string
toString	tests/catch.hpp	/^std::string toString(std::vector <T, Allocator> const &v) {$/;"	f	namespace:Catch	typeref:typename:std::string
toStringSuffix	tests/catch.hpp	/^  std::string toStringSuffix() const {$/;"	f	struct:Catch::Matchers::Impl::StdString::CasedString	typeref:typename:std::string
total	tests/catch.hpp	/^  std::size_t total() const {$/;"	f	struct:Catch::Counts	typeref:typename:std::size_t
totals	tests/catch.hpp	/^        Totals totals;$/;"	m	struct:Catch::AssertionStats	typeref:typename:Totals
totals	tests/catch.hpp	/^        Totals totals;$/;"	m	struct:Catch::TestCaseStats	typeref:typename:Totals
totals	tests/catch.hpp	/^        Totals totals;$/;"	m	struct:Catch::TestGroupStats	typeref:typename:Totals
totals	tests/catch.hpp	/^        Totals totals;$/;"	m	struct:Catch::TestRunStats	typeref:typename:Totals
tracker	tests/catch.hpp	/^            IndexTracker* tracker = CATCH_NULL;$/;"	m	class:Catch::TestCaseTracking::IndexTracker	typeref:typename:IndexTracker *
translateActiveException	tests/catch.hpp	/^        virtual std::string translateActiveException() const {$/;"	f	class:Catch::ExceptionTranslatorRegistry	typeref:typename:std::string
translateActiveException	tests/catch.hpp	/^    std::string translateActiveException() {$/;"	f	namespace:Catch	typeref:typename:std::string
trim	tests/catch.hpp	/^    std::string trim( std::string const& str ) {$/;"	f	namespace:Catch	typeref:typename:std::string
trueValue	tests/catch.hpp	/^  void trueValue() const {}$/;"	f	class:Catch::SafeBool	typeref:typename:void
tryAsMulti	tests/catch.hpp	/^        virtual MultipleReporters* tryAsMulti() { return CATCH_NULL; }$/;"	f	struct:Catch::IStreamingReporter	typeref:typename:MultipleReporters *
tryAsMulti	tests/catch.hpp	/^    virtual MultipleReporters* tryAsMulti() CATCH_OVERRIDE {$/;"	f	class:Catch::MultipleReporters	typeref:typename:MultipleReporters *
tryTranslators	tests/catch.hpp	/^        std::string tryTranslators() const {$/;"	f	class:Catch::ExceptionTranslatorRegistry	typeref:typename:std::string
type	tests/catch.hpp	/^            Type type;$/;"	m	struct:Clara::Parser::Token	typeref:typename:Type
type	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef<T const&>{ typedef T type; };$/;"	t	struct:Clara::Detail::RemoveConstRef	typeref:typename:T
type	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef<T const>{ typedef T type; };$/;"	t	struct:Clara::Detail::RemoveConstRef	typeref:typename:T
type	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef<T&>{ typedef T type; };$/;"	t	struct:Clara::Detail::RemoveConstRef	typeref:typename:T
type	tests/catch.hpp	/^        template<typename T> struct RemoveConstRef{ typedef T type; };$/;"	t	struct:Clara::Detail::RemoveConstRef	typeref:typename:T
type	tests/catch.hpp	/^  ResultWas::OfType type;$/;"	m	struct:Catch::MessageInfo	typeref:typename:ResultWas::OfType
type	tests/catch.hpp	/^  typedef void (SafeBool::*type)() const;$/;"	t	class:Catch::SafeBool	typeref:typename:void (SafeBool::*)()const
uint64_t	tests/catch.hpp	/^typedef unsigned long long uint64_t;$/;"	t	typeref:typename:unsigned long long
unexpectedExceptions	tests/catch.hpp	/^        unsigned int unexpectedExceptions;$/;"	m	class:Catch::JunitReporter	typeref:typename:unsigned int
unprintableString	tests/catch.hpp	/^    const std::string unprintableString = "{?}";$/;"	v	namespace:Catch::Detail	typeref:typename:const std::string
unusedTokens	tests/catch.hpp	/^        std::vector<Clara::Parser::Token> const& unusedTokens() const {$/;"	f	class:Catch::Session	typeref:typename:std::vector<Clara::Parser::Token> const &
usage	tests/catch.hpp	/^        std::string usage( std::string const& procName ) const {$/;"	f	class:Clara::CommandLine	typeref:typename:std::string
usage	tests/catch.hpp	/^        void usage( std::ostream& os, std::string const& procName ) const {$/;"	f	class:Clara::CommandLine	typeref:typename:void
use	tests/catch.hpp	/^            void use( Colour::Code ) {}$/;"	f	struct:Catch::__anond33fe2000410::NoColourImpl	typeref:typename:void
use	tests/catch.hpp	/^        virtual void use( Colour::Code _colourCode ) {$/;"	f	class:Catch::__anond33fe2000510::Win32ColourImpl	typeref:typename:void
use	tests/catch.hpp	/^        virtual void use( Colour::Code _colourCode ) {$/;"	f	class:Catch::__anond33fe2000610::PosixColourImpl	typeref:typename:void
use	tests/catch.hpp	/^    void Colour::use( Code _colourCode ) {$/;"	f	class:Catch::Colour	typeref:typename:void
useActiveException	tests/catch.hpp	/^    void ResultBuilder::useActiveException( ResultDisposition::Flags resultDisposition ) {$/;"	f	class:Catch::ResultBuilder	typeref:typename:void
useColour	tests/catch.hpp	/^        UseColour::YesOrNo useColour;$/;"	m	struct:Catch::ConfigData	typeref:typename:UseColour::YesOrNo
useColour	tests/catch.hpp	/^        virtual UseColour::YesOrNo useColour() const { return m_data.useColour; }$/;"	f	class:Catch::Config	typeref:typename:UseColour::YesOrNo
useConfigData	tests/catch.hpp	/^        void useConfigData( ConfigData const& _configData ) {$/;"	f	class:Catch::Session	typeref:typename:void
used	tests/catch.hpp	/^        bool used;$/;"	m	struct:Catch::LazyStat	typeref:typename:bool
validate	tests/catch.hpp	/^        void validate() const {$/;"	f	struct:Clara::CommonArgProperties	typeref:typename:void
validate	tests/catch.hpp	/^        void validate() const$/;"	f	class:Clara::CommandLine	typeref:typename:void
value	tests/catch.hpp	/^            T value;$/;"	m	struct:Catch::CumulativeReporterBase::Node	typeref:typename:T
value	tests/catch.hpp	/^        template<>              struct IsBool<bool> { static const bool value = true; };$/;"	m	struct:Clara::Detail::IsBool	typeref:typename:const bool
value	tests/catch.hpp	/^        template<typename T>    struct IsBool       { static const bool value = false; };$/;"	m	struct:Clara::Detail::IsBool	typeref:typename:const bool
value	tests/catch.hpp	/^  enum { value = sizeof(testStreamable(s << t)) == sizeof(TrueType) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anond33fe2000103
valueOr	tests/catch.hpp	/^  T valueOr(T const &defaultValue) const {$/;"	f	class:Catch::Option	typeref:typename:T
values	tests/catch.hpp	/^CompositeGenerator<T> values(T val1, T val2) {$/;"	f	namespace:Catch::Generators	typeref:typename:CompositeGenerator<T>
values	tests/catch.hpp	/^CompositeGenerator<T> values(T val1, T val2, T val3) {$/;"	f	namespace:Catch::Generators	typeref:typename:CompositeGenerator<T>
values	tests/catch.hpp	/^CompositeGenerator<T> values(T val1, T val2, T val3, T val4) {$/;"	f	namespace:Catch::Generators	typeref:typename:CompositeGenerator<T>
verbosity	tests/catch.hpp	/^        Verbosity::Level verbosity;$/;"	m	struct:Catch::ConfigData	typeref:typename:Verbosity::Level
visitChar	tests/catch.hpp	/^        void visitChar( char c ) {$/;"	f	class:Catch::TestSpecParser	typeref:typename:void
warnAboutMissingAssertions	tests/catch.hpp	/^        virtual bool warnAboutMissingAssertions() const { return m_data.warnings & WarnAbout::No/;"	f	class:Catch::Config	typeref:typename:bool
warnings	tests/catch.hpp	/^        WarnAbout::What warnings;$/;"	m	struct:Catch::ConfigData	typeref:typename:WarnAbout::What
which	tests/catch.hpp	/^            static Arch which() {$/;"	f	struct:Catch::Detail::__anond33fe2000810::Endianness	typeref:typename:Arch
width	tests/catch.hpp	/^        std::size_t width;          \/\/ maximum width of text, including indent. Longer text wi/;"	m	struct:CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:std::size_t
width	tests/catch.hpp	/^        std::size_t width;          \/\/ maximum width of text, including indent. Longer text wi/;"	m	struct:STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE::Tbc::TextAttributes	typeref:typename:std::size_t
withName	tests/catch.hpp	/^    TestCase TestCase::withName( std::string const& _newName ) const {$/;"	f	class:Catch::TestCase	typeref:typename:TestCase
writeAssertion	tests/catch.hpp	/^        void writeAssertion( AssertionStats const& stats ) {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
writeAssertions	tests/catch.hpp	/^        void writeAssertions( SectionNode const& sectionNode ) {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
writeAttribute	tests/catch.hpp	/^            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {$/;"	f	class:Catch::XmlWriter::ScopedElement	typeref:typename:ScopedElement &
writeAttribute	tests/catch.hpp	/^        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
writeAttribute	tests/catch.hpp	/^        XmlWriter& writeAttribute( std::string const& name, bool attribute ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
writeAttribute	tests/catch.hpp	/^        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
writeBlankLine	tests/catch.hpp	/^        XmlWriter& writeBlankLine() {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
writeComment	tests/catch.hpp	/^        XmlWriter& writeComment( std::string const& text ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
writeGroup	tests/catch.hpp	/^        void writeGroup( TestGroupNode const& groupNode, double suiteTime ) {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
writeSection	tests/catch.hpp	/^        void writeSection(  std::string const& className,$/;"	f	class:Catch::JunitReporter	typeref:typename:void
writeTestCase	tests/catch.hpp	/^        void writeTestCase( TestCaseNode const& testCaseNode ) {$/;"	f	class:Catch::JunitReporter	typeref:typename:void
writeText	tests/catch.hpp	/^            ScopedElement& writeText( std::string const& text, bool indent = true ) {$/;"	f	class:Catch::XmlWriter::ScopedElement	typeref:typename:ScopedElement &
writeText	tests/catch.hpp	/^        XmlWriter& writeText( std::string const& text, bool indent = true ) {$/;"	f	class:Catch::XmlWriter	typeref:typename:XmlWriter &
writeToDebugConsole	tests/catch.hpp	/^        void writeToDebugConsole( std::string const& text ) {$/;"	f	namespace:Catch	typeref:typename:void
xml	tests/catch.hpp	/^        XmlWriter xml;$/;"	m	class:Catch::JunitReporter	typeref:typename:XmlWriter
~AssertionResult	tests/catch.hpp	/^    AssertionResult::~AssertionResult() {}$/;"	f	class:Catch::AssertionResult
~AssertionStats	tests/catch.hpp	/^    AssertionStats::~AssertionStats() {}$/;"	f	class:Catch::AssertionStats
~AutoReg	tests/catch.hpp	/^    AutoReg::~AutoReg() {}$/;"	f	class:Catch::AutoReg
~BoundArgFunction	tests/catch.hpp	/^            ~BoundArgFunction() { delete functionObj; }$/;"	f	class:Clara::Detail::BoundArgFunction
~Colour	tests/catch.hpp	/^    Colour::~Colour(){ if( !m_moved ) use( None ); }$/;"	f	class:Catch::Colour
~CompactReporter	tests/catch.hpp	/^    CompactReporter::~CompactReporter() {}$/;"	f	class:Catch::CompactReporter
~CompositeGenerator	tests/catch.hpp	/^  ~CompositeGenerator() {$/;"	f	class:Catch::CompositeGenerator
~Config	tests/catch.hpp	/^        virtual ~Config() {$/;"	f	class:Catch::Config
~ConsoleReporter	tests/catch.hpp	/^    ConsoleReporter::~ConsoleReporter() {}$/;"	f	class:Catch::ConsoleReporter
~Contains	tests/catch.hpp	/^    Matchers::Impl::StdString::Contains::~Contains() {}$/;"	f	class:Catch::Matchers::Impl::StdString::Contains
~CoutStream	tests/catch.hpp	/^    CoutStream::~CoutStream() CATCH_NOEXCEPT {}$/;"	f	class:Catch::CoutStream
~CumulativeReporterBase	tests/catch.hpp	/^    CumulativeReporterBase::~CumulativeReporterBase() {}$/;"	f	class:Catch::CumulativeReporterBase
~DebugOutStream	tests/catch.hpp	/^    DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}$/;"	f	class:Catch::DebugOutStream
~EndsWith	tests/catch.hpp	/^    Matchers::Impl::StdString::EndsWith::~EndsWith() {}$/;"	f	class:Catch::Matchers::Impl::StdString::EndsWith
~Equals	tests/catch.hpp	/^    Matchers::Impl::StdString::Equals::~Equals() {}$/;"	f	class:Catch::Matchers::Impl::StdString::Equals
~ExceptionTranslatorRegistry	tests/catch.hpp	/^        ~ExceptionTranslatorRegistry() {$/;"	f	class:Catch::ExceptionTranslatorRegistry
~ExcludedPattern	tests/catch.hpp	/^    TestSpec::ExcludedPattern::~ExcludedPattern() {}$/;"	f	class:Catch::TestSpec::ExcludedPattern
~FatalConditionHandler	tests/catch.hpp	/^        ~FatalConditionHandler() {$/;"	f	struct:Catch::FatalConditionHandler
~File	file.cpp	/^File::~File() {$/;"	f	class:File
~FileStream	tests/catch.hpp	/^    FileStream::~FileStream() CATCH_NOEXCEPT {}$/;"	f	class:Catch::FileStream
~FreeFunctionTestCase	tests/catch.hpp	/^    FreeFunctionTestCase::~FreeFunctionTestCase() {}$/;"	f	class:Catch::FreeFunctionTestCase
~GeneratorsForTest	tests/catch.hpp	/^        ~GeneratorsForTest() {$/;"	f	class:Catch::GeneratorsForTest
~IArgFunction	tests/catch.hpp	/^            virtual ~IArgFunction() {}$/;"	f	struct:Clara::Detail::IArgFunction
~IColourImpl	tests/catch.hpp	/^            virtual ~IColourImpl() {}$/;"	f	struct:Catch::__anond33fe2000410::IColourImpl
~IConfig	tests/catch.hpp	/^    IConfig::~IConfig() {}$/;"	f	class:Catch::IConfig
~IContext	tests/catch.hpp	/^    IContext::~IContext() {}$/;"	f	class:Catch::IContext
~IExceptionTranslator	tests/catch.hpp	/^    IExceptionTranslator::~IExceptionTranslator() {}$/;"	f	class:Catch::IExceptionTranslator
~IExceptionTranslatorRegistry	tests/catch.hpp	/^    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}$/;"	f	class:Catch::IExceptionTranslatorRegistry
~IGenerator	tests/catch.hpp	/^  virtual ~IGenerator() {}$/;"	f	struct:Catch::IGenerator
~IGeneratorInfo	tests/catch.hpp	/^    IGeneratorInfo::~IGeneratorInfo() {}$/;"	f	class:Catch::IGeneratorInfo
~IGeneratorsForTest	tests/catch.hpp	/^    IGeneratorsForTest::~IGeneratorsForTest() {}$/;"	f	class:Catch::IGeneratorsForTest
~IMutableContext	tests/catch.hpp	/^    IMutableContext::~IMutableContext() {}$/;"	f	class:Catch::IMutableContext
~IMutableRegistryHub	tests/catch.hpp	/^    IMutableRegistryHub::~IMutableRegistryHub() {}$/;"	f	class:Catch::IMutableRegistryHub
~IRegistryHub	tests/catch.hpp	/^    IRegistryHub::~IRegistryHub() {}$/;"	f	class:Catch::IRegistryHub
~IReporter	tests/catch.hpp	/^    IReporter::~IReporter() {}$/;"	f	class:Catch::IReporter
~IReporterFactory	tests/catch.hpp	/^    IReporterFactory::~IReporterFactory() {}$/;"	f	class:Catch::IReporterFactory
~IReporterRegistry	tests/catch.hpp	/^    IReporterRegistry::~IReporterRegistry() {}$/;"	f	class:Catch::IReporterRegistry
~IResultCapture	tests/catch.hpp	/^    IResultCapture::~IResultCapture() {}$/;"	f	class:Catch::IResultCapture
~IRunner	tests/catch.hpp	/^    IRunner::~IRunner() {}$/;"	f	class:Catch::IRunner
~IShared	tests/catch.hpp	/^    IShared::~IShared() {}$/;"	f	class:Catch::IShared
~IStream	tests/catch.hpp	/^    IStream::~IStream() CATCH_NOEXCEPT {}$/;"	f	class:Catch::IStream
~IStreamingReporter	tests/catch.hpp	/^    IStreamingReporter::~IStreamingReporter() {}$/;"	f	class:Catch::IStreamingReporter
~ITagAliasRegistry	tests/catch.hpp	/^    ITagAliasRegistry::~ITagAliasRegistry() {}$/;"	f	class:Catch::ITagAliasRegistry
~ITestCase	tests/catch.hpp	/^    ITestCase::~ITestCase() {}$/;"	f	class:Catch::ITestCase
~ITestCaseRegistry	tests/catch.hpp	/^    ITestCaseRegistry::~ITestCaseRegistry() {}$/;"	f	class:Catch::ITestCaseRegistry
~ITracker	tests/catch.hpp	/^        ITracker::~ITracker() {}$/;"	f	class:Catch::TestCaseTracking::ITracker
~IndexTracker	tests/catch.hpp	/^        IndexTracker::~IndexTracker() {}$/;"	f	class:Catch::TestCaseTracking::IndexTracker
~JunitReporter	tests/catch.hpp	/^    JunitReporter::~JunitReporter() {}$/;"	f	class:Catch::JunitReporter
~LegacyReporterAdapter	tests/catch.hpp	/^    LegacyReporterAdapter::~LegacyReporterAdapter() {}$/;"	f	class:Catch::LegacyReporterAdapter
~Matcher	tests/catch.hpp	/^  virtual ~Matcher() {}$/;"	f	struct:Catch::Matchers::Impl::Matcher
~MethodTestCase	tests/catch.hpp	/^  virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase
~NamePattern	tests/catch.hpp	/^    TestSpec::NamePattern::~NamePattern() {}$/;"	f	class:Catch::TestSpec::NamePattern
~Node	tests/catch.hpp	/^            virtual ~Node() {}$/;"	f	struct:Catch::CumulativeReporterBase::Node
~NonCopyable	tests/catch.hpp	/^    NonCopyable::~NonCopyable() {}$/;"	f	class:Catch::NonCopyable
~NotImplementedException	tests/catch.hpp	/^  virtual ~NotImplementedException() CATCH_NOEXCEPT {}$/;"	f	class:Catch::NotImplementedException
~OcMethod	tests/catch.hpp	/^        virtual ~OcMethod() {}$/;"	f	class:Catch::OcMethod
~Option	tests/catch.hpp	/^  ~Option() {$/;"	f	class:Catch::Option
~Pattern	tests/catch.hpp	/^    TestSpec::Pattern::~Pattern() {}$/;"	f	class:Catch::TestSpec::Pattern
~Ptr	tests/catch.hpp	/^  ~Ptr() {$/;"	f	class:Catch::Ptr
~ReporterRegistry	tests/catch.hpp	/^        virtual ~ReporterRegistry() CATCH_OVERRIDE {}$/;"	f	class:Catch::ReporterRegistry
~RunContext	tests/catch.hpp	/^        virtual ~RunContext() {$/;"	f	class:Catch::RunContext
~ScopedElement	tests/catch.hpp	/^            ~ScopedElement() {$/;"	f	class:Catch::XmlWriter::ScopedElement
~ScopedMessage	tests/catch.hpp	/^    ScopedMessage::~ScopedMessage() {$/;"	f	class:Catch::ScopedMessage
~Section	tests/catch.hpp	/^    Section::~Section() {$/;"	f	class:Catch::Section
~SectionNode	tests/catch.hpp	/^    CumulativeReporterBase::SectionNode::~SectionNode() {}$/;"	f	class:Catch::CumulativeReporterBase::SectionNode
~SectionStats	tests/catch.hpp	/^    SectionStats::~SectionStats() {}$/;"	f	class:Catch::SectionStats
~SectionTracker	tests/catch.hpp	/^        SectionTracker::~SectionTracker() {}$/;"	f	class:Catch::TestCaseTracking::SectionTracker
~Session	tests/catch.hpp	/^        ~Session() {$/;"	f	class:Catch::Session
~StartsWith	tests/catch.hpp	/^    Matchers::Impl::StdString::StartsWith::~StartsWith() {}$/;"	f	class:Catch::Matchers::Impl::StdString::StartsWith
~StreamBufBase	tests/catch.hpp	/^    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}$/;"	f	class:Catch::StreamBufBase
~StreamBufImpl	tests/catch.hpp	/^        ~StreamBufImpl() CATCH_NOEXCEPT {$/;"	f	class:Catch::StreamBufImpl
~StreamRedirect	tests/catch.hpp	/^        ~StreamRedirect() {$/;"	f	class:Catch::StreamRedirect
~StreamingReporterBase	tests/catch.hpp	/^    StreamingReporterBase::~StreamingReporterBase() {}$/;"	f	class:Catch::StreamingReporterBase
~TagAliasRegistry	tests/catch.hpp	/^    TagAliasRegistry::~TagAliasRegistry() {}$/;"	f	class:Catch::TagAliasRegistry
~TagPattern	tests/catch.hpp	/^    TestSpec::TagPattern::~TagPattern() {}$/;"	f	class:Catch::TestSpec::TagPattern
~TestCaseStats	tests/catch.hpp	/^    TestCaseStats::~TestCaseStats() {}$/;"	f	class:Catch::TestCaseStats
~TestGroupStats	tests/catch.hpp	/^    TestGroupStats::~TestGroupStats() {}$/;"	f	class:Catch::TestGroupStats
~TestRegistry	tests/catch.hpp	/^    TestRegistry::~TestRegistry() {}$/;"	f	class:Catch::TestRegistry
~TestRunStats	tests/catch.hpp	/^    TestRunStats::~TestRunStats() {}$/;"	f	class:Catch::TestRunStats
~TrackerBase	tests/catch.hpp	/^        TrackerBase::~TrackerBase() {}$/;"	f	class:Catch::TestCaseTracking::TrackerBase
~WildcardPattern	tests/catch.hpp	/^    WildcardPattern::~WildcardPattern() {}$/;"	f	class:Catch::WildcardPattern
~XmlReporter	tests/catch.hpp	/^    XmlReporter::~XmlReporter() {}$/;"	f	class:Catch::XmlReporter
~XmlWriter	tests/catch.hpp	/^        ~XmlWriter() {$/;"	f	class:Catch::XmlWriter
